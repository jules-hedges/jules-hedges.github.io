<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Monadic lenses are the optic for right monad modules I</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Monadic lenses are the optic for right monad modules I</h1>
            <article>
    <section class="header">
        Posted on June  7, 2023
        
    </section>
    <section>
        <p>I figured out encoding of 2 more lens-like constructions in the “van Laarhoven” (functor quantification) style used by Haskell’s <a href="https://hackage.haskell.org/package/lens-5.2.2/docs/Control-Lens.html"><code>Control.Lens</code></a>. The first is monadic lenses, which allow your backwards pass to have side effects from a monad, and the second is the far more subtle monadic optics, which allow effects on both the forwards and backwards passes. I was originally surprised to find neither of these in the monolith-with-included-batteries that is <code>Control.Lens</code>. To summarise my findings:</p>
<ul>
<li>Monadic lenses are the optic for right modules of the monad</li>
<li>Monadic optics are the optic for right modules of the monad that additionally the monad distributes over</li>
</ul>
<p>Source code for this post can be found <a href="https://github.com/CyberCat-Institute/cybercat-core/blob/master/src/Cybercat/Sketches/MonadicLens.hs">here</a>. As usual I didn’t prove correctness of either of these, they’re only conjectures that seem to check out in code. In this post I’ll cover the first one, and then part II will be about the second, which is a lot more complicated. Let’s dive in.</p>
<p>In this post we’re working with a fixed monad, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>. A <strong>monadic</strong> lens from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math> is, by definition, a pair of a “forwards pass” or “get” function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">s \to a</annotation></semantics></math> and a “backwards pass” or “put” function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>b</mi><mo>→</mo><mi>m</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">s \times b \to m t</annotation></semantics></math>. This definition first appeared in section 2.3 of the paper <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/mlenses.pdf">Reflections on Monadic Lenses</a>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> The reason that the monad appears only on the backwards pass is that if we naively add it to the forwards pass (even if we also drop it from the backwards pass!) then lens composition completely fails to be associative. In the second half of this post we discuss how this is overcome.</p>
<p>Let’s open up the <a href="https://gaystepdadblog.wordpress.com/wp-content/uploads/2017/02/lets-dothings-together.png">bonnet</a> and remind ourselves how van Laarhoven lenses work. An ordinary lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) \to (a, b)</annotation></semantics></math>, which is concretely a pair of a forwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">s \to a</annotation></semantics></math> and a backwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>b</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s \times b \to t</annotation></semantics></math>, is encoded via quantification over all functors:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f t)</span></code></pre></div>
<p>In order to extract the forwards pass from this, we instantiate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to be the functor that is constant at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, leaving us with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>→</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \to a) \to (s \to a)</annotation></semantics></math>, and then applying the identity function. To extract the backwards pass, we instead instantiate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to be the identity functor, leaving us with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>→</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \to b) \to (s \to t)</annotation></semantics></math>, and then precomposing with the const function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">b \to a \to b</annotation></semantics></math> to get a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>s</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">b \to s \to t</annotation></semantics></math>.</p>
<p>Going the other way, in order to turn a concrete lens into a van Laarhoven lens we must produce an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f t</annotation></semantics></math> from a continuation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>f</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to f b</annotation></semantics></math> and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> knowing only that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is a functor. Using our <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>, we apply the forwards pass to get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> followed by the continuation to get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f b</annotation></semantics></math>. Then we partially apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> to the backwards pass to get a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">b \to t</annotation></semantics></math>, which we fmap over our <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f b</annotation></semantics></math> to get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f t</annotation></semantics></math>, which is what we needed.</p>
<p>So, in order to encode monadic lenses, we need to add a constraint that allows us to keep using the constant functor but prevents us using the identity functor. Instead of identity, in order to obtain the monadic backwards pass we would like to set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> itself, giving us <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>m</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>→</mo><mi>m</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \to m b) \to (s \to m t)</annotation></semantics></math>. From there, we can get a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>b</mi><mo>→</mo><mi>m</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">s \to b \to m t</annotation></semantics></math> using the constant pure function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi><mo>→</mo><mi>m</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">b \to a \to m b</annotation></semantics></math>.</p>
<p>Going the other way, let’s think about what we would need to know about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> in order to make an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>f</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>→</mo><mi>f</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \to f b) \to (s \to f t)</annotation></semantics></math> out of a monadic lens. Given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> we can apply the forwards pass to get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> and then the continuation to get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f b</annotation></semantics></math>, the same as before. Now if we fmap over the partially applied backwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>m</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">b \to m t</annotation></semantics></math> we can get an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (m t)</annotation></semantics></math>. But we wanted an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f t</annotation></semantics></math>, so what we need to know about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is that we have a way to do <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">f (m t) \to f t</annotation></semantics></math>.</p>
<p>It turns out that a functor that allows you to do this (for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>) is exactly what is called a <strong>right <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>-module</strong>. And everything lines up: constant functors are always right modules trivially, every monad is a right module of itself by the monad multiplication, and the identity functor is not a right module unless you can escape the monad.</p>
<p>If a monad is just a monoid in the category of endofunctors, then a right module is a right action of that monoid… what’s the problem? Right modules of monads do occasionally crop up in functional programming, see for example <a href="https://research-information.bris.ac.uk/ws/portalfiles/portal/87127912/Nicolas_Wu_String_Diagrams_for_Free_Monads.pdf">this paper</a>.</p>
<p>Here’s the key bits of the <a href="https://github.com/CyberCat-Institute/cybercat-core/blob/master/src/Cybercat/Sketches/MonadicLens.hs">code</a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">RightModule</span> m f <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    act ::</span> f (m a) <span class="ot">-&gt;</span> f a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">RightModule</span> m m <span class="kw">where</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    act <span class="ot">=</span> join</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">RightModule</span> m (<span class="dt">Const</span> a) <span class="kw">where</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    act <span class="ot">=</span> <span class="dt">Const</span> <span class="op">.</span> getConst</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MonadicLens</span> m s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Functor</span> f, <span class="dt">RightModule</span> m f) <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f s t a b</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ot">monadicGet ::</span> <span class="dt">MonadicLens</span> m s t a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>monadicGet l s <span class="ot">=</span> getConst (l (<span class="dt">Const</span>) s)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="ot">monadicPut ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadicLens</span> m s t a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m t</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>monadicPut l s b <span class="ot">=</span> l (<span class="fu">const</span> (<span class="fu">return</span> b)) s</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="ot">monadicLens ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m t) <span class="ot">-&gt;</span> <span class="dt">MonadicLens</span> m s t a b</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>monadicLens g p k s <span class="ot">=</span> act (<span class="fu">fmap</span> (p s) (k (g s)))</span></code></pre></div>
<p>And that’s it! I had to switch on incoherent instances to make this compile, but I think that’s just Haskell being Haskell – I think it’s unable to figure out that the two instances can never overlap because <code>Const a</code> is not a monad.</p>
<p>This was the easy part. Stay tuned for part 2 where we’ll also add the monad to the forwards pass.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Editor’s note: Jeremy Gibbons commented that the definition appears slightly earlier in <a href="https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/entangled.pdf">this paper</a> and also independently in <a href="https://dl.acm.org/doi/10.1145/2543728.2543737">this paper</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
