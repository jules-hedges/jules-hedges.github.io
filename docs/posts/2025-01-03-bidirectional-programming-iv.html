<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Foundations of bidirectional programming IV: Running forwards and running backwards</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Foundations of bidirectional programming IV: Running forwards and running backwards</h1>
            <article>
    <section class="header">
        Posted on January  3, 2025
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2025/01/03/bidirectional-programming-iv/">X-posted on the CyberCat Institute blog</a>)</p>
<p>See parts <a href="../posts/2024-08-26-bidirectional-programming-i.html">I</a>, <a href="../posts/2024-09-05-bidirectional-programming-ii.html">II</a> and <a href="../posts/2024-09-12-bidirectional-programming-iii.html">III</a></p>
<p>We are now at the point where we can write an interpreter to run some programs. To be clear, this is mainly for demonstration and debugging purposes, and the eventual goal is to write an optimising compiler. By the end of this post we will be able to demonstrate interpreting some very simple straight-line differentiable programs, and also demonstrate just how horrendous it is to actually write programs in our kernel syntax. This will motivate several follow-up posts where we slowly work upwards towards a human-usable surface language.</p>
<p>Continuing our well-typed-by-construction methodology we will build a <em>well typed interpreter</em>. This means that we first interpret types of our language into Idris types, and then these give the type of the corresponding interpreted program. For languages less weird than ours, such as one of the example languages from the <a href="../posts/2024-08-26-bidirectional-programming-i.html">first post</a>, we would interpret terms as Idris functions, resulting in signatures like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">EvalType</span> <span class="op">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>eval <span class="op">:</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">EvalType</span> xs <span class="ot">-&gt;</span> <span class="dt">EvalType</span> x</span></code></pre></div>
<p>Instead of interpreting to Idris functions, terms of Aptwe will be interpreted as <em>lenses</em>. For this we need to give 2 different interpretations of each type, one covariant and the other contravariant:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Cov</span> <span class="op">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Con</span> <span class="op">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>eval <span class="op">:</span> <span class="dt">Term</span> xs x <span class="ot">-&gt;</span> <span class="dt">Lens</span> (<span class="dt">All</span> <span class="dt">Cov</span> xs) (<span class="dt">All</span> <span class="dt">Con</span> xs) (<span class="dt">Cov</span> x) (<span class="dt">Con</span> x)</span></code></pre></div>
<h2 id="base-types">Base types</h2>
<p>We need to start by defining <code>Cov</code> and <code>Con</code>, which is completely straightforward. This is the point at which we upgrade our type language to have a proper mechanism for base types (source code is <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Builtins/Types.idr">here</a> and <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Kernel/Types.idr">here</a>):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BaseTy</span> <span class="op">:</span> <span class="dt">Kind</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nat</span> <span class="op">:</span> <span class="dt">BaseTy</span> (<span class="dt">True</span>, <span class="dt">False</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bool</span> <span class="op">:</span> <span class="dt">BaseTy</span> (<span class="dt">True</span>, <span class="dt">True</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Real</span> <span class="op">:</span> <span class="dt">BaseTy</span> (<span class="dt">True</span>, <span class="dt">True</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> <span class="op">:</span> <span class="dt">Kind</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BaseTy</span> <span class="op">:</span> <span class="dt">BaseTy</span> (cov, con) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (cov, con)</span></code></pre></div>
<p>This gives us 3 base types to play with: naturals (aka. ints), booleans, and reals (aka. doubles). I have made the choice that naturals will be purely covariant, whereas booleans and reals will be bivariant. As we will discover, interpreting a bivariant type amounts to choosing a canonical commutative monoid structure on it, which becomes baked into that type’s scoping rules: every time we do something that looks like shadowing, instead the monoid operation will be applied.</p>
<p>These choices come from key applications: for reals it will be addition which is used in autodiff (see the last section of this post), and for booleans it will be conjunction which is used in compositional game theory (see a future post). Of course addition is also an obvious choice for naturals, but since I don’t know any application for it in bidirectional programming, I have instead made naturals purely covariant.</p>
<p>Base types are also responsible for the only non-obvious part of our interpreter for types:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Echo</span> <span class="op">:</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">X</span> <span class="op">:</span> <span class="dt">Echo</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>mutual</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> <span class="op">:</span> <span class="dt">Ty</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> <span class="dt">Unit</span> <span class="ot">=</span> <span class="dt">Unit</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> (<span class="dt">BaseTy</span> x) <span class="ot">=</span> <span class="dt">EvalBaseTy</span> x</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> (<span class="dt">Not</span> x) <span class="ot">=</span> <span class="dt">Con</span> x</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> (<span class="dt">Tensor</span> x y) <span class="ot">=</span> (<span class="dt">Cov</span> x, <span class="dt">Cov</span> y)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> <span class="op">:</span> <span class="dt">Ty</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> <span class="dt">Unit</span> <span class="ot">=</span> <span class="dt">Unit</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> (<span class="dt">BaseTy</span> x) <span class="ot">=</span> <span class="dt">Echo</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> (<span class="dt">Not</span> x) <span class="ot">=</span> <span class="dt">Cov</span> x</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> (<span class="dt">Tensor</span> x y) <span class="ot">=</span> (<span class="dt">Con</span> x, <span class="dt">Con</span> y)</span></code></pre></div>
<p>The type <code>Echo</code> is an isomorphic copy of <code>Unit</code>. The choice I have made is that base types have a nontrivial interpretation only in the covariant direction. The name <em>echo</em> refers to the indescribable thing that is observed when looking at something travelling through time in the opposite direction to the observer. Its value <code>X</code> ends up proliferating through interpreted terms, but this is only something we’ll have to put up with while using this prototype interpreter.</p>
<h2 id="interpreting-structure">Interpreting structure</h2>
<p>The next thing we need to do is to interpret <em>structure</em>, that is, the data structure <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Kernel/Structure.idr">here</a> that is used in the <code>Rename</code> case of terms. In principle a renaming could be interpreted as a lens, but it transpires that renamings only ever mean lenses whose backwards pass does not use its forwards input (I call these <em>adaptors</em>). This means that we actually need to write 2 functions:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>structureCov <span class="op">:</span> <span class="dt">Structure</span> xs ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Cov</span> xs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Cov</span> ys</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>structureCon <span class="op">:</span> <span class="dt">Structure</span> xs ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> xs</span></code></pre></div>
<p>All of the source code from this section can be found in <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Interpreter/Structure.idr">this file</a>.</p>
<p>The hard part of this is to interpret the 4 operations of <em>delete</em>, <em>copy</em>, <em>spawn</em> and <em>merge</em>. Interpreting delete and copy of covariant values is easy, since it ends up being delete and copy of Idris values. Similarly interpreting spawn and merge of contravariant values also ends up being delete and copy of Idris values. So what we need to do is to spawn and merge covariant values, and to delete and copy contravariant values, and this is where we need to make a choice of a monoid structure for each base type:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>unit <span class="op">:</span> {x <span class="op">:</span> <span class="dt">BaseTy</span> (cov, <span class="dt">True</span>)} <span class="ot">-&gt;</span> <span class="dt">Cov</span> (<span class="dt">BaseTy</span> x)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>unit {x <span class="ot">=</span> <span class="dt">Bool</span>} <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>unit {x <span class="ot">=</span> <span class="dt">Real</span>} <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>multiply <span class="op">:</span> {x <span class="op">:</span> <span class="dt">BaseTy</span> (cov, <span class="dt">True</span>)} </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Cov</span> (<span class="dt">BaseTy</span> x) <span class="ot">-&gt;</span> <span class="dt">Cov</span> (<span class="dt">BaseTy</span> x) <span class="ot">-&gt;</span> <span class="dt">Cov</span> (<span class="dt">BaseTy</span> x)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>multiply {x <span class="ot">=</span> <span class="dt">Bool</span>} p q <span class="ot">=</span> p <span class="op">&amp;&amp;</span> q</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>multiply {x <span class="ot">=</span> <span class="dt">Real</span>} p q <span class="ot">=</span> p <span class="op">+</span> q</span></code></pre></div>
<p>Now we can delete and spawn because <code>unit</code> takes care of the missing base case for base types:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>mutual</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  spawnCov <span class="op">:</span> {x <span class="op">:</span> <span class="dt">Ty</span> (cov, <span class="dt">True</span>)} <span class="ot">-&gt;</span> <span class="dt">Cov</span> x</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  spawnCov {x <span class="ot">=</span> <span class="dt">Unit</span>} <span class="ot">=</span> ()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  spawnCov {x <span class="ot">=</span> <span class="dt">BaseTy</span> x} <span class="ot">=</span> unit</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  spawnCov {x <span class="ot">=</span> <span class="dt">Not</span> x} <span class="ot">=</span> deleteCon</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  deleteCon <span class="op">:</span> {x <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, con)} <span class="ot">-&gt;</span> <span class="dt">Con</span> x</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  deleteCon {x <span class="ot">=</span> <span class="dt">Unit</span>} <span class="ot">=</span> ()</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  deleteCon {x <span class="ot">=</span> <span class="dt">BaseTy</span> x} <span class="ot">=</span> <span class="dt">X</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  deleteCon {x <span class="ot">=</span> <span class="dt">Not</span> x} <span class="ot">=</span> spawnCov</span></code></pre></div>
<p>The case for spawning or deleting a tensor product <em>should</em> be</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  spawnCov {x <span class="ot">=</span> <span class="dt">Tensor</span> x y} <span class="ot">=</span> (spawnCov, spawnCov)</span></code></pre></div>
<p>But instead this case takes us into a very unfortunate corner case of Idris syntax, which I’m not going to attempt to explain because I only partially understand what’s going on:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  spawnCov {x <span class="ot">=</span> <span class="dt">Tensor</span> {con <span class="ot">=</span> (<span class="dt">True</span> <span class="op">**</span> <span class="fu">and</span>)} x y} with (<span class="fu">and</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    spawnCov {x <span class="ot">=</span> <span class="dt">Tensor</span> {con <span class="ot">=</span> (<span class="dt">True</span> <span class="op">**</span> <span class="fu">and</span>)} x y} <span class="op">|</span> <span class="dt">True</span> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> (spawnCov, spawnCov)</span></code></pre></div>
<p>The cases for copy/merge are almost identical. Now we can write the functions we need, for which the interesting cases are as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>structureCov <span class="op">:</span> <span class="dt">Structure</span> xs ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Cov</span> xs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Cov</span> ys</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>structureCov (<span class="dt">Delete</span> f) (<span class="ot">x ::</span> xs) <span class="ot">=</span> structureCov f xs</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>structureCov (<span class="dt">Copy</span> e f) xs <span class="ot">=</span> ixSelect e<span class="ot"> xs ::</span> structureCov f xs</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>structureCov (<span class="dt">Spawn</span> f) xs <span class="ot">= spawnCov ::</span> structureCov f xs</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>structureCov (<span class="dt">Merge</span> e f) (<span class="ot">x ::</span> xs) <span class="ot">=</span> applyAt e (mergeCov x) (structureCov f xs)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>structureCon <span class="op">:</span> <span class="dt">Structure</span> xs ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> ys <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> xs</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>structureCon (<span class="dt">Delete</span> f) ys <span class="ot">= deleteCon ::</span> structureCon f ys</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>structureCon (<span class="dt">Copy</span> e f) (<span class="ot">y ::</span> ys) <span class="ot">=</span> applyAt e (copyCon y) (structureCon f ys)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>structureCon (<span class="dt">Spawn</span> f) (<span class="ot">y ::</span> ys) <span class="ot">=</span> structureCon f ys</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>structureCon (<span class="dt">Merge</span> e f) ys <span class="ot">=</span> ixSelect e<span class="ot"> ys ::</span> structureCon f ys</span></code></pre></div>
<p>Observe that the covariant delete case and the contravariant spawn case become a deletion in Idris, meaning that the head of the list does not appear on the right hand side. Similarly the cases for covariant copy and contravariant delete use the helper function <code>ixSelect</code>, which in the end is copying a value from the middle of the list to its head. This leaves the remaining cases to call our 4 helper functions: covariant spawning and merging, and contravariant deleting and copying.</p>
<h2 id="writing-the-interpreter">Writing the interpreter</h2>
<p>Now we come to the main thing: writing the function</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>eval <span class="op">:</span> <span class="dt">Term</span> xs y <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Cov</span> xs <span class="ot">-&gt;</span> (<span class="dt">Cov</span> y, <span class="dt">Con</span> y <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> xs)</span></code></pre></div>
<p>The complete implementation is <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Interpreter/Terms.idr">here</a>. Let’s start with a couple of very easy cases to warm up:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">BaseTerm</span> t) xs <span class="ot">=</span> evalBaseTerm t xs</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">Var</span> [x] <span class="ot">=</span> (x, \y' <span class="ot">=&gt;</span> [y'])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>eval <span class="dt">UnitIntro</span> [] <span class="ot">=</span> ((), \() <span class="ot">=&gt;</span> [])</span></code></pre></div>
<p>The case for renaming is not much harder, since we spent the whole of the previous section writing the helper functions it needs:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Rename</span> f t) xs <span class="ot">=</span> <span class="kw">let</span> (y, k) <span class="ot">=</span> eval t (structureCov f xs)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> (y, \y' <span class="ot">=&gt;</span> structureCon f (k y'))</span></code></pre></div>
<p>Probably the most instructive case is the one for <code>Let</code>. When writing an ordinary interpreter of terms into functions <code>Let</code> becomes function composition, or slightly more precisely <em>substitution</em> into one input of a many-input function. For us, <code>Let</code> becomes lens composition. The one complication, which also happens in most of the remaining cases, is that we need to use the simplex carried by the proof rule to tell us how to pull apart the input list into two, and then stitch it back together.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Let</span> {cs <span class="ot">=</span> (_ <span class="op">**</span> _ <span class="op">**</span> s)} t1 t2) xs</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> (y, k1) <span class="ot">=</span> eval t1 (ixUncatL s xs)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        (z, k2) <span class="ot">=</span> eval t2 (<span class="ot">y ::</span> ixUncatR s xs)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (z, \z' <span class="ot">=&gt;</span> <span class="kw">let</span><span class="ot"> y' ::</span> ys' <span class="ot">=</span> k2 z'</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> ixConcat s (k1 y') ys')</span></code></pre></div>
<p>The subtlety of this case is just the subtlety of lens composition: the first output of <code>t1</code> in the forwards direction becomes an input of <code>t2</code> in the forwards direction, and then the continuations are unwound in reverse order for the backwards direction. The helper functions</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ixConcat <span class="op">:</span> <span class="dt">IxSimplex</span> as bs cs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q as <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q bs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q cs</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ixUncatL <span class="op">:</span> <span class="dt">IxSimplex</span> as bs cs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q cs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q as</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>ixUncatR <span class="op">:</span> <span class="dt">IxSimplex</span> as bs cs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q cs <span class="ot">-&gt;</span> <span class="dt">IxAll</span> q bs</span></code></pre></div>
<p>which can be found in <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/IxUtils.idr">IxUtils</a>, respectively stitch or unstitch a pair of indexed lists as directed by a simplex.</p>
<p>Next let’s look at the introduction and elimination rules for <code>Tensor</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">TensorIntro</span> {cs <span class="ot">=</span> (_ <span class="op">**</span> _ <span class="op">**</span> s)} t1 t2) xs </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> (y1, k1) <span class="ot">=</span> eval t1 (ixUncatL s xs)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        (y2, k2) <span class="ot">=</span> eval t2 (ixUncatR s xs)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> ((y1, y2), \(y1', y2') <span class="ot">=&gt;</span> ixConcat s (k1 y1') (k2 y2'))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">TensorElim</span> {cs <span class="ot">=</span> (_ <span class="op">**</span> _ <span class="op">**</span> s)} t1 t2) xs </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> ((y1, y2), k1) <span class="ot">=</span> eval t1 (ixUncatL s xs)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        (y2, k2) <span class="ot">=</span> eval t2 (<span class="ot">y1 :: y2 ::</span> ixUncatR s xs)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (y2, \y' <span class="ot">=&gt;</span> <span class="kw">let</span><span class="ot"> x1' :: x2' ::</span> xs' <span class="ot">=</span> k2 y'</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> ixConcat s (k1 (x1', x2')) xs')</span></code></pre></div>
<p>The case for <code>TensorIntro</code> is nothing but the tensor product of two lenses, and the elimination rule is extremely similar to <code>Let</code> but binds two variables at once, namely the two halves of the product being eliminated.</p>
<p>This marks the dividing line between the cases I was able to understand before writing them, and the ones for which I really relied on the Idris type checker for help. What remains is the unit elimination rule, and the rules for negation. In an ordinary language the unit elimination rule is very easy: any term that returns a unit can be completely discarded. But for us, a term that returns a unit can still produce output backwards:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">UnitElim</span> {cs <span class="ot">=</span> (_ <span class="op">**</span> _ <span class="op">**</span> s)} t1 t2) xs </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> ((), k1) <span class="ot">=</span> eval t1 (ixUncatL s xs)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        (y, k2) <span class="ot">=</span> eval t2 (ixUncatR s xs)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (y, \y' <span class="ot">=&gt;</span> ixConcat s (k1 ()) (k2 y'))</span></code></pre></div>
<p>Arguably, the most important rule in the entire language is negation elimination, because it is the only rule that directly allows communication from the forwards pass to the backwards pass. In traditional differentiable programming terminology, the implementation of this rule is to write to the tape. Here is its implementation:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">NotElim</span> {cs <span class="ot">=</span> (_ <span class="op">**</span> _ <span class="op">**</span> s)} t1 t2) xs </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> (y1, k1) <span class="ot">=</span> eval t1 (ixUncatL s xs)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        (y2, k2) <span class="ot">=</span> eval t2 (ixUncatR s xs)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> ((), \() <span class="ot">=&gt;</span> ixConcat s (k1 y2) (k2 y1))</span></code></pre></div>
<p>This leaves the 2 negation introdution rules that, as I wrote in the previous post, I discovered while working on these cases for the interpreter. They are truly <em>sus</em>, and while writing this post I changed my mind several times about whether they should be in the language or whether they are mistakes. Currently the deciding factor is that one of them, the covariant one, is actually required in practice: we will use it repeatedly in the next section when implementing differentiable functions.</p>
<p>In a sense the negation introduction rules are <em>scoping</em> rules rather than computational rules: they use the helper functions we developed for the interpretation of <code>Rename</code>, but themselves cannot be expressed in terms of <code>Rename</code>. My provisional conclusion is that these rules need to be in the language because I don’t have any alternative, but they are very much on thin ice.</p>
<p>Here is the code I wrote:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">NotIntroCov</span> t) xs </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> (deleteCon, \x' <span class="ot">=&gt;</span> <span class="kw">let</span> ((), k) <span class="ot">=</span> eval t (<span class="ot">x' ::</span> xs)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ot">                           y' ::</span> ys <span class="ot">=</span> k ()</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> ys)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">NotIntroCon</span> t) xs </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> ((), k) <span class="ot">=</span> eval t (<span class="ot">spawnCov ::</span> xs) </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="ot">        y ::</span> ys <span class="ot">=</span> k ()</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (y, \y' <span class="ot">=&gt;</span> ys)</span></code></pre></div>
<p>It is worth meditating on these definitions. Both of them delete something “and then” spawn a monoid unit to replace it (in category theory this is called a <em>zero morphism</em>), and they use the lack of causal flow from the input to the output to move the scopes around in a way that is impossible to do with the other rules.</p>
<h2 id="our-first-program">Our first program</h2>
<p>The code for this section and the next can be found <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/Examples/Differentiation.idr">here</a>.</p>
<p>From the start of this blog series until now we have been pretty far down the abstraction ladder, far enough that it is hard to remember what the point is. Now we can finally run programs, let’s finally return to near the surface by implementing a baby example of automatic differentiation.</p>
<p>There are essentially two main aspects to automatic differentiation. The first is the reverse chain rule, which is the name in calculus for the fundamental computational model of Aptwe. The other is the purely syntactic procedure that associates each primitive element of a program with its reverse derivative, the starting point from which the reverse chain rule differentiates the entire program compositionally. This second thing is not something we can do yet, and in my opinion it is not a feature that belongs in a kernel language, instead belonging in a surface language specialised to differentiable programming. So, we will write a program where each primitive function is “decorated” with its reverse derivative and then the reverse chain rule takes care of the rest.</p>
<p>For now, I have defined <em>base terms</em> to be terms that carry around an Idris lens, and the corresponding interpreter cases simply apply the forward and backward passes of that lens as functions:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BaseTerm</span> <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> ks <span class="ot">-&gt;</span> <span class="dt">Ty</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Builtin</span> <span class="op">:</span> (<span class="dt">IxAll</span> <span class="dt">Cov</span> xs <span class="ot">-&gt;</span> (<span class="dt">Cov</span> y, <span class="dt">Con</span> y <span class="ot">-&gt;</span> <span class="dt">IxAll</span> <span class="dt">Con</span> xs)) <span class="ot">-&gt;</span> <span class="dt">BaseTerm</span> xs y</span></code></pre></div>
<p>This is temporary for as long as we are using the prototype interpreter; eventually something much more subtle will be needed here. Using this, we can for example lift functions between doubles into Aptwe terms:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sin</span> <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">BaseTy</span> <span class="dt">Real</span>] (<span class="dt">BaseTy</span> <span class="dt">Real</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sin</span> <span class="ot">=</span> <span class="dt">BaseTerm</span> <span class="op">$</span> <span class="dt">Builtin</span> <span class="op">$</span> \[x] <span class="ot">=&gt;</span> (<span class="fu">sin</span> x, \<span class="dt">X</span> <span class="ot">=&gt;</span> [<span class="dt">X</span>])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="fu">cos</span> <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">BaseTy</span> <span class="dt">Real</span>] (<span class="dt">BaseTy</span> <span class="dt">Real</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="fu">cos</span> <span class="ot">=</span> <span class="dt">BaseTerm</span> <span class="op">$</span> <span class="dt">Builtin</span> <span class="op">$</span> \[x] <span class="ot">=&gt;</span> (<span class="fu">cos</span> x, \<span class="dt">X</span> <span class="ot">=&gt;</span> [<span class="dt">X</span>])</span></code></pre></div>
<p>These functions respectively apply sin and cos in the forward pass, and are trivial in the backward pass. Similarly, we can multiply two doubles in the forward pass with the function</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>times <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">BaseTy</span> <span class="dt">Real</span>, <span class="dt">BaseTy</span> <span class="dt">Real</span>] (<span class="dt">BaseTy</span> <span class="dt">Real</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>times <span class="ot">=</span> <span class="dt">BaseTerm</span> <span class="op">$</span> <span class="dt">Builtin</span> <span class="op">$</span> \[x, y] <span class="ot">=&gt;</span> (x <span class="op">*</span> y, \<span class="dt">X</span> <span class="ot">=&gt;</span> [<span class="dt">X</span>, <span class="dt">X</span>])</span></code></pre></div>
<p>It will be useful to have a shorthand for types of “monomorphic” lenses, ie. whose forwards and backwards types are the same, since autodiff functions all have this form:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Mono</span> <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, <span class="dt">True</span>) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (<span class="dt">True</span>, <span class="dt">True</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Mono</span> a <span class="ot">=</span> <span class="dt">Tensor</span> a (<span class="dt">Not</span> a)</span></code></pre></div>
<p>Our main goal is to implement a combinator <code>diff</code> which takes a term representing a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and its ordinary derivative <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mo>′</mo></msup><annotation encoding="application/x-tex">f'</annotation></semantics></math> and combines them as follows. The forward pass is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> itself, ie. it takes the forward input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to the forward output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (x)</annotation></semantics></math>. Now we take the equation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\frac{dy}{dx} = f' (x)</annotation></semantics></math> and rearrange it to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mfrac><mn>1</mn><mrow><mi>d</mi><mi>y</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{dx} = f' (x) \cdot \frac{1}{dy}</annotation></semantics></math>. The backward pass implements this equation as a function, ie. it takes the forward input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and backward input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{1}{dy}</annotation></semantics></math> to the backward output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mfrac><mn>1</mn><mrow><mi>d</mi><mi>y</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">f' (x) \cdot \frac{1}{dy}</annotation></semantics></math>.</p>
<p>The problem with the following code is that it’s incomprehensible for (at least) 2 different reasons:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>diff <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">BaseTy</span> <span class="dt">Real</span>] (<span class="dt">BaseTy</span> <span class="dt">Real</span>) <span class="ot">-&gt;</span> <span class="dt">Term</span> [<span class="dt">BaseTy</span> <span class="dt">Real</span>] (<span class="dt">BaseTy</span> <span class="dt">Real</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>diff f df <span class="ot">=</span> <span class="dt">TensorElim</span> <span class="dt">Var</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">Rename</span> (<span class="dt">Copy</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">TensorIntro</span> f</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">NotIntroCov</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">Rename</span> (<span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">NotElim</span> <span class="dt">Var</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> <span class="dt">Let</span> df</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span> times</span></code></pre></div>
<p>The first reason is that variables are referred to by their position rather than by name. The second reason is that programming with elimination forms like <code>TensorElim</code> and (especially) <code>NotElim</code> is just very unintuitive. To be honest, I don’t expect anybody to understand it because I don’t exactly understand it myself, but it does work. Some highlights are the <code>Copy</code> on line 4 which copies the forward input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> because it is used by both the forward and backward passes, and the last line which is the multiplication of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x)</annotation></semantics></math> by the backward input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mrow><mi>d</mi><mi>y</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{1}{dy}</annotation></semantics></math>.</p>
<p>It was suffering through writing this function (and debugging it, since on my first try I got the 2 inputs to the backward pass the wrong way round) that made me decide to push towards a human-understandable language faster than I originally intended to.</p>
<p>Now, to write a differentiable sin function we just have to say what its derivative is:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>dsin <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>dsin <span class="ot">=</span> diff <span class="fu">sin</span> <span class="fu">cos</span></span></code></pre></div>
<p>To run <code>dsin</code> we need to call <code>eval</code> on it, but also pack and unpack some boxes:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>dtest <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)) </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span>, <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>dtest t x <span class="ot">=</span> <span class="kw">let</span> ((y, <span class="dt">X</span>), k) <span class="ot">=</span> eval t [(x, <span class="dt">X</span>)]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> (y, \dy <span class="ot">=&gt;</span> <span class="kw">let</span> [(<span class="dt">X</span>, dx)] <span class="ot">=</span> k (<span class="dt">X</span>, dy)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> dx)</span></code></pre></div>
<h2 id="autodiff">Autodiff</h2>
<p>Before we stop we should write a <em>slightly</em> less trivial function, just to make sure that we are doing autodiff correctly when we compose things together. Let’s write the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mi>sin</mi><mo>⁡</mo></mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x \sin x^2</annotation></semantics></math>. Although Aptwe has the chain rule built in, we need to write a differentiable multiplication that contains the essence of the product rule. If you thought <code>diff</code> was painful, this one is worse:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>dtimes <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>), <span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>dtimes <span class="ot">=</span> <span class="dt">TensorElim</span> <span class="dt">Var</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">Rename</span> (<span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="op">$</span> <span class="dt">Copy</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">TensorElim</span> <span class="dt">Var</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">Rename</span> (<span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="op">$</span> <span class="dt">Copy</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))) </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>               <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">TensorIntro</span> times</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">NotIntroCov</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">Rename</span> (<span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="op">$</span> <span class="dt">Copy</span> <span class="dt">Z</span> </span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>               <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)) <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">NotElim</span> <span class="dt">Var</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> <span class="dt">UnitElim</span> (<span class="dt">NotElim</span> <span class="dt">Var</span> <span class="op">$</span> times)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>       <span class="op">$</span> times</span></code></pre></div>
<p>This calls <code>times</code> (our base term for ordinary, non-autodiff multiplication) 3 different times, once in the forward pass for the actual multiplication, and twice more in the backward pass: remember the product rule contains 2 instances of multiplication <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>⋅</mo><mi>g</mi><msup><mo stretchy="false" form="postfix">)</mo><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><msup><mi>g</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f \cdot g)' (x) = f (x) \cdot g' (x) + f' (x) \cdot g (x)</annotation></semantics></math>. But notice, there is no corresponding subterm for addition. Instead, there are 3 instances of <code>Copy</code>: in order of appearance, 2 to copy each of the forward inputs which are used once each in the forward and backward passes, and 1 more which is actually merging a negative variable. This last <code>Copy</code> is actually the addition in the product rule.</p>
<p>There are two pieces of good news. The first is that this function works (I even got this one right first try, although it took me about an hour), and the second is that we are over the hill, everything after this point should be actually understandable.</p>
<p>We can implement squaring in terms of multiplcation by copying the input:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>dsquare <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>dsquare <span class="ot">=</span> <span class="dt">Rename</span> (<span class="dt">Copy</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">$</span> dtimes</span></code></pre></div>
<p>Something important is happening here. This <code>Copy</code> is being applied to a variable of type <code>Mono (BaseTy Real)</code>, which is the tensor product of the forward input and the backward output. Copying a tensor product is copying each part, but copying the negative part is actually a merge, which is addition. So this single <code>Copy</code> is a true autodiff copy, which is simultaneously copying in the forward pass and adding in the backward pass. So we never need to specify that the deriative of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mn>2</mn></msup><annotation encoding="application/x-tex">x^2</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x</annotation></semantics></math>, and instead we get it as a consequence of the product rule.</p>
<p>Now we have all the pieces for our slightly more complicated example of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mi>sin</mi><mo>⁡</mo></mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x \sin x^2</annotation></semantics></math>, whose only difficulty is writing without variable names:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>example <span class="op">:</span> <span class="dt">Term</span> [<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>)] (<span class="dt">Mono</span> (<span class="dt">BaseTy</span> <span class="dt">Real</span>))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="dt">Rename</span> (<span class="dt">Copy</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Insert</span> <span class="dt">Id</span> <span class="dt">Z</span> <span class="op">$</span> <span class="dt">Empty</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> <span class="dt">Let</span> (<span class="dt">Let</span> dsquare dsin)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span> dtimes</span></code></pre></div>
<p>And it works! We can use our testing function from before to verify that the backward pass gives the correct reverse derivative, which is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mrow><mi>sin</mi><mo>⁡</mo></mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup><mrow><mi>cos</mi><mo>⁡</mo></mrow><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mfrac><mn>1</mn><mrow><mi>d</mi><mi>y</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{dx} = (\sin x^2 + 2 x^2 \cos x^2) \cdot \frac{1}{dy}</annotation></semantics></math>.</p>
<p>In conclusion, everything works but is absolutely horrendous to program in. In principle this is fine because Aptwe is explicitly intended to be a kernel language and not to be written by humans. But after this experience I have decided to prioritise working towards a prototype frontend language, for demonstration purposes and for the sake of my own sanity. My plan is to build a series of elaboration passes in reverse order of the compiler pipeline:</p>
<ul>
<li>Replace elimination forms with patterns (this is particularly important because Aptwe is substructural, so we can’t take the easy option of adding primitives for projection out of products)</li>
<li>Type inference (which is very straightforward right now because Aptwe is still simply typed)</li>
<li>Scope checking and kind inference (uniquely to Aptwe, I expect these to be interconnected in an interesting way)</li>
<li>Parsing a concrete syntax</li>
</ul>
<p>On the other side of the scope checking pass, we will have a language with names rather than positional variables, and this is the point at which programming should become humanly possible.</p>
<p>Separately to this I also want to add some more primitives to the kernel language, particularly linear function types and linear coproducts (the <em>par</em> operator of linear logic). The eventual goal is to support algebraic datatypes, but there is still basic research to be done on the theory of datatypes in categories of lenses. Of course we will also need to build in some non-algebraic datatypes, the most obvious example being tensors. My plan is to work on these features in parallel with working on the frontend language, so expect the next few blog posts to alternate between these topics.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
