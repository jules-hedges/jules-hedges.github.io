<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Towards dependent optics</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Towards dependent optics</h1>
            <article>
    <section class="header">
        Posted on June 10, 2020
        
    </section>
    <section>
        <p>There are two different generalises of <a href="../posts/2018-08-16-lenses-for-philosophers.html">lenses</a> that are important in my research. One is <a href="https://arxiv.org/abs/1809.00738">optics</a>, which are a non-obvious generalisation of lenses that work over a monoidal category (whereas lenses only work over a finite product category). We use optics in <a href="https://arxiv.org/abs/1910.03656">Bayesian open games</a>, over the category of Markov kernels (kleisli category of probability). The other is dependent lenses, also known as containers and equivalent to polynomial functors. These haven’t appeared in a game theory paper yet, but I use them privately to handle external choice of games better than lenses do.</p>
<p>An interesting and probably-hard question is to find a common generalisation of optics and dependent lenses.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> In this post I’ll outline the problem and explain a (probable) partial solution that might be useful for somebody, but doesn’t appear useful in game theory. This post will be heavy on category theory: I assume knowledge of fibred categories and the Grothendieck construction.</p>
<p>If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a finite product category and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> are objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, then a lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) \to (a, b)</annotation></semantics></math> is a pair of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">v : s \to a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><mi>s</mi><mo>×</mo><mi>b</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">u : s \times b \to t</annotation></semantics></math>. Lenses form a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Lens} (\mathcal C)</annotation></semantics></math>. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is only a monoidal category and we try to define a lens by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">v : s \to a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><mi>s</mi><mo>⊗</mo><mi>b</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">u : s \otimes b \to t</annotation></semantics></math> then the composition fails to be associative, so they do not form a category.</p>
<p>There is one way to recover lenses over a monoidal category: we require <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> to be comonoids in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, and we require <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">v : s \to a</annotation></semantics></math> to be a comonoid homomorphism. For my particular use case this is no good. I take <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> to be the category of Markov kernels, in which every object is canonically a comonoid, but the comonoid homomorphisms are exactly the deterministic maps. In game theory the forwards part is <em>play</em> and is generally stochastic.</p>
<p>The “view” functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lens} (\mathcal C) \to \mathcal C</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>↦</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">(s, t) \mapsto s</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mo>↦</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">(v, u) \mapsto v</annotation></semantics></math> turns out to be a fibration. The fibre over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> turns out to be the opposite of the co-kleisli category of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>−</mi></mrow><annotation encoding="application/x-tex">s \times -</annotation></semantics></math> (reader) comonad on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>. (This co-kleisli category was characterised in Lambek and Scott’s <a href="https://github.com/Mzk-Levi/texts/blob/master/Lambek%20J.%2C%20Scott%20P.J.%20Introduction%20to%20Higher%20Order%20Categorical%20Logic.pdf">Introduction to higher order categorical logic</a>: it is the “polynomial category” <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo stretchy="false" form="prefix">[</mo><mi>s</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\mathcal C [s]</annotation></semantics></math> that results from freely adjoining a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">1 \to s</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and then closing under finite products.) So the category of lenses can be equivalently constructed via the Grothendieck construction:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mo>∫</mo><mrow><mi>s</mi><mo>∈</mo><mi>𝒞</mi></mrow></msup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>×</mo><mi>−</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>=</mo><msup><mo>∫</mo><mrow><mi>s</mi><mo>∈</mo><mi>𝒞</mi></mrow></msup><mi>𝒞</mi><mo stretchy="false" form="prefix">[</mo><mi>s</mi><msup><mo stretchy="false" form="postfix">]</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \displaystyle \mathbf{Lens} (\mathcal C) = \int^{s \in \mathcal C} \mathrm{coKl}(s \times -)^{\mathrm{op}} = \int^{s \in \mathcal C} \mathcal C [s]^{\mathrm{op}} </annotation></semantics></math></p>
<p>Next I’ll talk about dependent lenses. I’m not sure exactly what structure you need on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> to make it work, I think locally cartesian closed with pullbacks, but if in doubt I’m really thinking about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>=</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C = \mathbf{Set}</annotation></semantics></math>. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> are objects and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">t(s)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b(a)</annotation></semantics></math> are dependent types (formally, “fibre bundles” <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">t \to s</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \to a</annotation></semantics></math>), then a dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) \to (a, b)</annotation></semantics></math> consists of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">v : s \to a</annotation></semantics></math> and (written in pseudo-Agda notation) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>:</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">u : (s : S) \to b (v (s)) \to t (s)</annotation></semantics></math>, that is, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><msub><mo>∏</mo><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">u : \prod_{s \in S} (b (v (s)) \to a (s))</annotation></semantics></math>. In purely categorical terms, this is a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><mi>s</mi><msub><mo>×</mo><mi>a</mi></msub><mi>b</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">u : s \times_a b \to t</annotation></semantics></math> such that the composite <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><msub><mo>×</mo><mi>a</mi></msub><mi>b</mi><mo>→</mo><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s \times_a b \to t \to s</annotation></semantics></math> equals the projection. They form a category, which I’ll call <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{DLens} (\mathcal C)</annotation></semantics></math>.</p>
<p>David Spivak taught me this construction, which is apparently folkloric in algebraic geometry. It is a special case of morphisms of ringed spaces, where both spaces and rings are replaced by sets. Ordinary lenses are the full subcategory in which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">t(s)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b(a)</annotation></semantics></math> are constants, or in fibrational terms, when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>t</mi><mo>→</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">s \times t \to s</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \times b \to a</annotation></semantics></math> are the projections. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{DLens} (\mathcal C)</annotation></semantics></math> is also known as the <a href="https://people.cs.nott.ac.uk/psztxa/publ/fossacs03.pdf">category of containers</a>, and I believe that (maybe with some more assumptions) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{DLens} (\mathcal C)</annotation></semantics></math> is equivalent to the category of polynomial endofunctors and (all) natural transformations on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>.</p>
<p>I’ll say something about why dependent lenses come up in game theory. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{DLens} (\mathcal C)</annotation></semantics></math> is complete and cocomplete, but in particular I need that it has all coproducts. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐬</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Lens} (\mathbf{set})</annotation></semantics></math>, on the other hand, only has coproducts of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>+</mo><mi>a</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) + (a, t) = (s + a, t)</annotation></semantics></math>. Coproducts of this form are used to construct the external choice operator on open games, which is extremely useful in practice: see sections 8-9 of <a href="https://arxiv.org/abs/1711.07059">Morphisms of open games</a>. If we try to take an external choice between open games with source types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math>, then if we insert a state in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> then we get out a coutility in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, and if we insert a state in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> then we get out a coutility in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>. Thus the type of coutility is the dependent type over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">s + a</annotation></semantics></math> that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<p>In this sense dependent types enter the problem “naturally”. Taking a coproduct of ordinary lenses, in general, will result in a dependent lens. Working with open games over the category of dependent lenses will make life easier by making the external choice operator defined everywhere, which makes the resulting graphical language (surface diagrams over a bimonoidal/rig category) significantly better behaved. The catch is that this can only be done for pure strategies, so my difficult question amounts to: how to do this for Bayesian open games? It can be <em>hacked</em> over lenses but is an unexploded bomb, because taking a cross section through a surface diagram need not result in a well-defined object.</p>
<p>There is still a fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathbf{DLens} (\mathcal C) \to \mathcal C</annotation></semantics></math>. This time it turns out that the fibre over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> is the opposite of the slice category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mi>/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\mathcal C / s</annotation></semantics></math>. It turns out that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mi>/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\mathcal C / s</annotation></semantics></math> is also equivalent to the co-Eilenberg-Moore category of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>−</mi></mrow><annotation encoding="application/x-tex">s \times -</annotation></semantics></math> comonad. (I find this the most beautiful part of the whole story.) Thus we can also construct the category of dependent lenses by Grothendieck:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mo>∫</mo><mrow><mi>s</mi><mo>∈</mo><mi>𝒞</mi></mrow></msup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">E</mi><mi mathvariant="normal">M</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>×</mo><mi>−</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>=</mo><msup><mo>∫</mo><mrow><mi>s</mi><mo>∈</mo><mi>𝒞</mi></mrow></msup><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mi>/</mi><mi>s</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \displaystyle \mathbf{DLens} (\mathcal C) = \int^{s \in \mathcal C} \mathrm{coEM} (s \times -)^{\mathrm{op}} = \int^{s \in \mathcal C} (\mathcal C / s)^{\mathrm{op}} </annotation></semantics></math></p>
<p>Finally on to optics. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a monoidal category and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> are objects then the appropriate generalisation of lenses, which are called optics <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) \to (a, b)</annotation></semantics></math>, are elements of the coend (in the category of sets)</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mrow><mi>x</mi><mo>∈</mo><mi>𝒞</mi></mrow></msup><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>x</mi><mo>⊗</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>⊗</mo><mi>b</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \displaystyle \int^{x \in \mathcal C} \mathcal C (s, x \otimes a) \times \mathcal C (x \otimes b, t) </annotation></semantics></math></p>
<p>They form a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math>. When the monoidal product of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a categorical product, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> is equivalent to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Lens} (\mathcal C)</annotation></semantics></math>, by an argument involving the <a href="https://arxiv.org/abs/1501.02503">Ninja Yoneda Lemma</a> (which says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>hom</mi><annotation encoding="application/x-tex">\hom</annotation></semantics></math> behaves like a Dirac measure for the integral). Optics have many interesting special cases and also can be generalised further to <em>mixed optics</em>, see <a href="https://arxiv.org/abs/2001.07488">A categorical update</a>.</p>
<p>One nice thing about the previous cases breaks down: there is no longer a view functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C) \to \mathcal C</annotation></semantics></math>, let alone a fibration.</p>
<p>Here is one notion of “dependent optics” which might be useful for somebody, but is not what I need in game theory. This starts from <a href="https://mathoverflow.net/questions/205902/what-is-the-monoidal-equivalent-of-a-locally-cartesian-closed-category">this MathOverflow post</a> (which was <a href="https://x.com/sarah_zrf/status/1270394907291791360">brought to my attention by sarahzrf</a>) whose answers say that <em>in some sense</em> the appropriate analogue of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mi>/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\mathcal C / s</annotation></semantics></math> when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is monoidal is the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Comod} (s)</annotation></semantics></math> of <a href="https://ncatlab.org/nlab/show/comodule">comodules over a commutative comonoid</a> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>.</p>
<p>A comonoid homomorphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">s \to a</annotation></semantics></math> appears to lift to a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Comod} (s) \to \mathbf{Comod} (a)</annotation></semantics></math> (for the slice category this is contravariant, this is one point that I don’t understand yet). A morphism which is not a comonoid homomorphism <a href="https://x.com/_julesh_/status/1270677270529744896">does not lift in this way</a>. So I believe we can define a category of sort-of “dependent optics” by Grothendieck construction:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐃</mi><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mo>∫</mo><mrow><mi>s</mi><mo>∈</mo><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> \displaystyle \mathbf{DOptic} (\mathcal C) = \int^{s \in \mathbf{Comon} (\mathcal C)} \mathbf{Comod} (s)^{\mathrm{op}} </annotation></semantics></math></p>
<p>Unfortunately this means that the forwards maps in the category category are forced to be comonoid homomorphisms, so this is actually a generalisation of <em>lenses</em> over a monoidal category as I defined at the beginning, rather than a generalisation of optics, and are not suitable for my problem for the same reason.</p>
<p>Fundamentally I expect the “true” category of dependent optics will not be a fibred category, as ordinary optics are not, and so this strategy of defining the category by Grothendieck construction starting from a generalisation of the individual fibres was doomed from the start.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Editor’s note: In retrospect this was probably the greatest understatement of my career.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
