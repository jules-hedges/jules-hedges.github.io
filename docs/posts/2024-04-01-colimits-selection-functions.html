<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Colimits of selection functions</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Colimits of selection functions</h1>
            <article>
    <section class="header">
        Posted on April  1, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/04/01/colimits-selection-functions/">X-posted on the CyberCat Institute blog</a>)</p>
<p>In <a href="https://arxiv.org/abs/2105.06332">Towards Foundations of Categorical Cybernetics</a> we built a category whose objects are selection functions and whose morphisms are lenses. It was a key step in how we <em>justified</em> open games in that paper: they’re <em>just</em> parametrised lenses “weighted” by selection functions. In this post I’ll show that by adding dependent types and stirring, we can get a nicer category that does the same job but has all colimits, and comes extremely close to having all limits. Fair warning: this post assumes quite a bit of category-theoretic background.</p>
<p>Besides being a nice thing to do in itself, we have a very specific motivation for this. The recently realised paper <a href="https://arxiv.org/abs/2402.15332">Categorical deep learning: An algebraic theory of architectures</a> proposed using initial algebras and final coalgebras in categories of parametrised morphisms to build neural networks with learning invariants designed to operate on complex data structures, in a huge generalisation of <a href="https://geometricdeeplearning.com/">geometric deep learning</a>. This post is the first step to replicating the same structure in compositional game theory, and is probably the first case where a class of deep learning architectures has a game-theoretic analogue right from the beginning (ok, the first other than <a href="https://en.wikipedia.org/wiki/Generative_adversarial_network">GANs</a>) - something that is absolutely key to our vision of AI safety, as I described in <a href="https://cybercat.institute/2024/03/18/learning-invariant-preferences/">this previous post</a>.</p>
<h1 id="dependent-lenses">Dependent lenses</h1>
<p>In this post I’m going work over the category of sets, to make my life easy. A <strong>container</strong> (also known as a <strong>polynomial functor</strong>) is a pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is a set and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>′</mo></msup><annotation encoding="application/x-tex">X'</annotation></semantics></math> is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of sets.</p>
<p>Given a pair of containers, a <strong>dependent lens</strong> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> is a pair of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><msup><mi>Y</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' : (x : X) \times Y' (f (x)) \to X' (x)</annotation></semantics></math>. There’s a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><annotation encoding="application/x-tex">\mathbf{DLens}</annotation></semantics></math> whose objects are containers and whose morphisms are dependent lenses (also known as the <em>category of containers</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐧</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cont}</annotation></semantics></math> and the <em>category of polynomial functors</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐏</mi><mi>𝐨</mi><mi>𝐥</mi><mi>𝐲</mi></mrow><annotation encoding="application/x-tex">\mathbf{Poly}</annotation></semantics></math> by different authors).</p>
<p>The category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><annotation encoding="application/x-tex">\mathbf{DLens}</annotation></semantics></math> has all limits and colimits, distinguishing it from the category of simply-typed lenses which is missing many of both (see my old paper <a href="https://arxiv.org/abs/1711.07059">Morphisms of Open Games</a>). In this post I want to just take that as a given fact, because calculating them is not always so easy. The slick way to prove it is by constructing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><annotation encoding="application/x-tex">\mathbf{DLens}</annotation></semantics></math> as a fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mrow><mi>X</mi><mo>:</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mi>/</mi><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\int_{X : \mathbf{Set}} \left( \mathbf{Set} / X \right)^\mathrm {op}</annotation></semantics></math>, and using the fact that a fibred category has all co/limits if every fibre does and reindexing preserves them (a fact that we’ll be seeing again later).</p>
<h1 id="dependent-selection-functions">Dependent selection functions</h1>
<p>Write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> for the tensor unit of dependent lenses: it’s made of the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">1 = \{ * \}</annotation></semantics></math> and the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-indexed set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>*</mi><mo>↦</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">* \mapsto 1</annotation></semantics></math>. A dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">I \to \binom{X}{X'}</annotation></semantics></math> is an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>, and a dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to I</annotation></semantics></math> is a <em>section</em> of the container: a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k : (x : X) \to X' (x)</annotation></semantics></math>. For shorthand I’ll write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">H = \mathbf{DLens} (I, -) : \mathbf{DLens} \to \mathbf{Set}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>I</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msup><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">K = \mathbf{DLens} (-, I) : \mathbf{DLens}^\mathrm{op} \to \mathbf{Set}</annotation></semantics></math> for these representable functors.</p>
<p>By analogy to <a href="https://julesh.com/2021/03/30/selection-functions-and-lenses/">what happens in the simply-typed case</a>, a <strong>dependent selection function</strong> for a container <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math> should be a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon : K \binom{X}{X'} \to H \binom{X}{X'}</annotation></semantics></math> - that is, a thing that turns costates into states.</p>
<p>But I think we’re going to need things to be multi-valued in order to get all colimits (and we need it to do much game theory anyway), so let’s immediately forget that and define a <strong>dependent multi-valued selection function</strong> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math> to be a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>⊆</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon \subseteq H \binom{X}{X'} \times K \binom{X}{X'}</annotation></semantics></math>.</p>
<p>To be honest, I don’t really have any serious examples of these things to hand, I think they’ll arise from taking colimits of things that are simply-typed. For game theory the main one we care about is still <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>arg</mi><mo>⁡</mo></mrow><mi>max</mi></mrow><annotation encoding="application/x-tex">\arg\max</annotation></semantics></math>, which <em>is</em> a “dependent” multi-valued selection function but only in a boring way that doesn’t use the dependent types - it’s a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>arg</mi><mo>⁡</mo></mrow><mrow><mi>max</mi><mo>⁡</mo></mrow><mo>⊆</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>ℝ</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>ℝ</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\arg\max \subseteq H \binom{X}{\mathbb R} \times K \binom{X}{\mathbb R}</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi><annotation encoding="application/x-tex">\mathbb R</annotation></semantics></math> here means the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed set that is constantly the real numbers.</p>
<p>For each container <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math>, write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝒫</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">E \binom{X}{X'} = \mathcal P \left( H \binom{X}{X'} \times K \binom{X}{X'} \right)</annotation></semantics></math> for the set of multi-valued selection functions for it. Since it’s a powerset it inherits a posetal structure from subset inclusion, which is a boolean algebra. That means that as a thin category, it has all limits and colimits, something that will come in useful later.</p>
<p>Given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>⊆</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon \subseteq H \binom{X}{X'} \times K \binom{X}{X'}</annotation></semantics></math> and a dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> we can define a “pushforward” selection function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f_* (\varepsilon) \subseteq H \binom{Y}{Y'} \times K \binom{Y}{Y'}</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mi>f</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>ε</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">f_* (\varepsilon) = \{ (hf, k) \mid (h, fk) \in \varepsilon \}</annotation></semantics></math>. Defining it this way means we get functoriality for free, and it’s also monotone, so we have a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>:</mo><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo>→</mo><mrow><mi>𝐏</mi><mi>𝐨</mi><mi>𝐬</mi></mrow></mrow><annotation encoding="application/x-tex">E : \mathbf{DLens} \to \mathbf{Pos}</annotation></semantics></math>.</p>
<p>The fact that we could just as easily have defined a contravariant action on dependent lenses means that the fibration we’re about to get is a bifibration, something that will <em>definitely</em> come in useful one day, but not today.</p>
<h1 id="colimits-of-selection-functions">Colimits of selection functions</h1>
<p>The next thing we do is take the category of elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math>. Objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> are pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>ε</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( \binom{X}{X'}, \varepsilon \right)</annotation></semantics></math> of a container and a selection function for it. A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>ε</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \left( \binom{X}{X'}, \varepsilon \right) \to \left( \binom{Y}{Y'}, \delta \right)</annotation></semantics></math> is a dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> with the property that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="postfix">)</mo><mo>≤</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">f_* (\varepsilon) \leq \delta</annotation></semantics></math> - which is to say, any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>H</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h : H \binom{X}{X'}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k : K \binom{Y}{Y'}</annotation></semantics></math> satisfying <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">(h, fk) \in \varepsilon</annotation></semantics></math> must also satisfy <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mi>f</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">(hf, k) \in \delta</annotation></semantics></math>.</p>
<p>So, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> is a category whose objects are dependent multi-valued selection functions and morphisms are dependent lenses. The only difference to the original category of selection functions from <a href="https://arxiv.org/abs/2105.06332">Towards Foundations</a> is that we replaced simply typed lenses with dependent lenses. This is enough to get all limits, and I’d call <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> a “nice category of selection functions”.</p>
<p>The good way to prove that a fibred category has all co/limits (see <a href="https://arxiv.org/abs/1801.02927">this paper</a>) is to show that (1) the base category has all co/limits, (2) every fibre has all co/limits, and (3) reindexing preserves co/limits. We already know (1) and (2) (remember the fibres are all boolean algebras), so we just need to prove (3). Since limits and colimits in the fibres are unions and intersections, this should not be too hard.</p>
<p>For some container <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math>, suppose we have some family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>i</mi></msub><mo>⊆</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon_i \subseteq E \binom{X}{X'}</annotation></semantics></math> indexed by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i : I</annotation></semantics></math>. We can define the meet <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋀</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bigwedge_{i : I} \varepsilon_i</annotation></semantics></math> and join <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋁</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>ε</mi><mi>i</mi></msub><mo>:</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\bigvee_{i : I} \varepsilon_i : E \binom{X}{X'}</annotation></semantics></math> by intersection and union. To get all colimits in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math>, what we need to prove is that for any dependent lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>⋁</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>⋁</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_* \left( \bigvee_{i : I} \varepsilon_i \right) = \bigvee_{i : I} f_* (\varepsilon_i)</annotation></semantics></math>. Let’s do it:</p>
<p>Going forwards, suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>f</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(h, k) \in f_* \left( \bigvee_i \varepsilon_i \right)</annotation></semantics></math>, so by definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mo>*</mo></msub><annotation encoding="application/x-tex">f_*</annotation></semantics></math> there must be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>h</mi><mo>′</mo></msup><annotation encoding="application/x-tex">h'</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msup><mi>h</mi><mo>′</mo></msup><mi>f</mi></mrow><annotation encoding="application/x-tex">h = h'f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(h', fk) \in \bigvee_i \varepsilon_i</annotation></semantics></math>. So there is some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i : I</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(h', fk) \in \varepsilon_i</annotation></semantics></math>, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mi>f</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h'f, k) = (h, k) \in f_* (\varepsilon_i)</annotation></semantics></math>, therefore <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, k) \in \bigvee_i f_* (\varepsilon_i)</annotation></semantics></math>.</p>
<p>The other direction, suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, k) \in \bigvee_i f_* (\varepsilon_i)</annotation></semantics></math>, so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, k) \in f_* (\varepsilon_i)</annotation></semantics></math> for some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i : I</annotation></semantics></math>. So we must have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>h</mi><mo>′</mo></msup><annotation encoding="application/x-tex">h'</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msup><mi>h</mi><mo>′</mo></msup><mi>f</mi></mrow><annotation encoding="application/x-tex">h = h'f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(h', fk) \in \varepsilon_i</annotation></semantics></math>. So <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(h', fk) \in \bigvee_i \varepsilon_i</annotation></semantics></math>, therefore <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>h</mi><mo>′</mo></msup><mi>f</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>f</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>⋁</mo><mi>i</mi></msub><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(h'f, k) = (h, k) \in f_* \left( \bigvee_i \varepsilon_i \right)</annotation></semantics></math>.</p>
<p>Note, this is intentionally a pure existence proof. Actually calculating these things can be quite a pain, and I’m going to put it off until later, specifically until a paper we’re cooking up on <em>branching</em> open games.</p>
<h1 id="limits-of-selection-functions">Limits of selection functions</h1>
<p>If we also had <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>⋀</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>⋀</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_* \left( \bigwedge_{i : I} \varepsilon_i \right) = \bigwedge_{i : I} f_* (\varepsilon_i)</annotation></semantics></math> then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> would also have all limits, but sadly in general the best we can do is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mo>⋀</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>⊆</mo><msub><mo>⋀</mo><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_* \left( \bigwedge_{i : I} \varepsilon_i \right) \subseteq \bigwedge_{i : I} f_* (\varepsilon_i)</annotation></semantics></math>. I’d guess this probably means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> has some kind of lax limits or something, but I’ll deal with that another day.</p>
<p>It’s instructive to look at what goes wrong. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mo>⋀</mo><mi>i</mi></msub><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, k) \in \bigwedge_i f_* (\varepsilon_i)</annotation></semantics></math>, then for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i : I</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>ε</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, k) \in f_* (\varepsilon_i)</annotation></semantics></math>. So, for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><annotation encoding="application/x-tex">h'_i</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><mi>f</mi></mrow><annotation encoding="application/x-tex">h = h'_i f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><mo>,</mo><mi>f</mi><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(h'_i, fk) \in \varepsilon_i</annotation></semantics></math>. We can make progress if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is a monomorphism, in which case all of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><annotation encoding="application/x-tex">h'_i</annotation></semantics></math> are equal because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><mi>f</mi><mo>=</mo><mi>h</mi><mo>=</mo><msub><msup><mi>h</mi><mo>′</mo></msup><mi>j</mi></msub><mi>f</mi></mrow><annotation encoding="application/x-tex">h'_i f = h = h'_j f</annotation></semantics></math> implies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>h</mi><mo>′</mo></msup><mi>i</mi></msub><mo>=</mo><msub><msup><mi>h</mi><mo>′</mo></msup><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">h'_i = h'_j</annotation></semantics></math>. In fact, while I don’t know what general monomorphisms in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><annotation encoding="application/x-tex">\mathbf{DLens}</annotation></semantics></math> look like, in this case it’s enough that the forwards pass of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is an injective function. This probably gives us a decent subcategory of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">\int E</annotation></semantics></math> that has all limits as well as all colimits, but I don’t know whether that category will be useful for anything.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
