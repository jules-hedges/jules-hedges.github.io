<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Subgame perfection made difficult</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Subgame perfection made difficult</h1>
            <article>
    <section class="header">
        Posted on May 26, 2020
        
    </section>
    <section>
        <p>This is the second post in catching up on aspects of <a href="https://github.com/CyberCat-Institute/open-game-engine">open-games-hs</a> that are ahead of my papers, following <a href="../posts/2020-05-17-open-games-stateful-payoffs.html">open games with stateful payoffs</a>. Subgame perfection has been an embarrassing thorn in my side since 2016 when I had to do major surgery on <a href="../posts/2018-01-16-towards-compositional-game-theory.html">my PhD thesis</a> because the category of “open games with subgame perfect equilibria” turned out to not be monoidal. Currently there are two approaches: One in <a href="https://arxiv.org/abs/1711.07968">iterated open games</a> which is quite pragmatic and requires the “user” specifying an open game to manually mark where the subgames are by applying a functor; and one in <a href="https://arxiv.org/abs/1711.07059">morphisms of open games</a> which I find very elegant but requires both an extra categorical dimension and an equivalent amount of effort by the “user”.</p>
<p>I always wanted an “automatic” approach to subgame perfection in open games, like I failed to do in my thesis – just draw the usual string diagram, and get subgame perfect equilibria out. I now have a way to do it, implemented in <a href="https://github.com/CyberCat-Institute/open-game-engine/blob/og-v0.1/src/OpenGames/Engine/SubgamePerfect.hs"><code>OpenGames.Engine.SubgamePerfect</code></a>, which I’ll document here.</p>
<p>The starting point is an idea that doesn’t work. In the category of deterministic open games, a decision <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒟</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D} : (X, 1) \to (Y, \mathbb{R})</annotation></semantics></math> has strategy profiles <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi>𝒟</mi></msub><mo>=</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\Sigma_\mathcal{D} = X \to Y</annotation></semantics></math>, and equilibria <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><mi>𝒟</mi></msub><mo>:</mo><mi>X</mi><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>→</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝒫</mi><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Σ</mi><mi>𝒟</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_\mathcal{D} : X \times (Y \to \mathbb{R}) \to \mathcal{P} (\Sigma_\mathcal{D})</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><mi>𝒟</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>σ</mi><mo>∣</mo><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mrow><mi>arg</mi><mo>⁡</mo></mrow><mrow><mi>max</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_\mathcal{D} (h, k) = \{ \sigma \mid \sigma(h) \in \arg\max (k) \}</annotation></semantics></math>. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> plays the role of the on-equilibrium subgame. Here is an idea that doesn’t work: instead define it by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><mi>𝒟</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>σ</mi><mo>∣</mo><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mrow><mi>arg</mi><mo>⁡</mo></mrow><mrow><mi>max</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> for all </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mo>∈</mo><mi>X</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_\mathcal{D} (h, k) = \{ \sigma \mid \sigma(x) \in \arg\max (k) \text{ for all } x \in X \}</annotation></semantics></math>.</p>
<p>To see why this doesn’t work, form the game <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝒟</mi><mi mathvariant="normal">Δ</mi></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mn>1</mn><mi>X</mi></msub><mo>⊗</mo><mi>𝒟</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi mathvariant="normal">Δ</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo>,</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}^\Delta = (1_X \otimes \mathcal{D}) \circ \Delta : (X, 1) \to (X \times Y, \mathbb{R})</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>×</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Delta : (X, 1) \to (X \times X, 1)</annotation></semantics></math> lifts the copy function. Given a context with history <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">h : X</annotation></semantics></math> and continuation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">k : X \times Y \to \mathbb{R}</annotation></semantics></math>, its equilibrium condition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><msup><mi>𝒟</mi><mi mathvariant="normal">Δ</mi></msup></msub><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_{\mathcal{D}^\Delta} (h, k)</annotation></semantics></math> is equivalent to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><mrow><msub><mn>1</mn><mi>X</mi></msub><mo>⊗</mo><mi>𝒟</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_{1_X \otimes \mathcal{D}} ((h, h), k)</annotation></semantics></math> and then to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐄</mi><mi>𝒟</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><msup><mi>k</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{E}_{\mathcal{D}} (h, k')</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k' (y) = k (h, y)</annotation></semantics></math>. If we keep the true definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐄</mi><mi>𝒟</mi></msub><annotation encoding="application/x-tex">\mathbf{E}_{\mathcal{D}}</annotation></semantics></math> then this is carefully balanced to give us Nash. But if we use our proposed modified definition, the equilibrium condition becomes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mrow><mi>arg</mi><mo>⁡</mo></mrow><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow></msub><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma (x) \in \arg\max_{y \in Y} k (h, y)</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math>. This is wrong – the subgame perfect equilibrium condition should be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mrow><mi>arg</mi><mo>⁡</mo></mrow><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow></msub><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma (x) \in \arg\max_{y \in Y} k (x, y)</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x \in X</annotation></semantics></math>.</p>
<p>What is happening is that the context of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒟</mi><annotation encoding="application/x-tex">\mathcal{D}</annotation></semantics></math> should keep track of how a conterfactual change to its history, from the on-equilibrium subgame <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> to an off-equilibrium subgame <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, should propagate to the continuation, which should change from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k (h, -)</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k (x, -)</annotation></semantics></math>.</p>
<p>Fortunately we’re in luck. The heavy machinery developed in <a href="https://arxiv.org/abs/1910.03656">Bayesian open games</a> is able to handle exactly this sort of situation. The first thought is to replace the category of stochastic maps with the category of relations. Pushing forward the state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \subseteq X</annotation></semantics></math> through the copy map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math> yields the diagonal set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mo>*</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo stretchy="false" form="postfix">}</mo><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\Delta^* (X) = \{ (x, x) | x \in X \} \subseteq X \times X</annotation></semantics></math>, which contains exactly enough information to propagate a counterfactual change in one output backwards and then forwards again to the other output. That is to say, if we take the pushfoward state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mo>*</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Delta^* (X)</annotation></semantics></math> and condition on one output being some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, the other output collapses to the same <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. This much is standard reasoning in the category of relations.</p>
<p>This is almost right, but not quite. We also need to keep track of what <em>actually</em> happens, and not just the counterfactual alternatives, in particular because they are still used for payoffs: a player’s preferences are indifferent to payoffs that might have occurred, but did not. We actually need to simultaneously keep track of 3 levels of possibility: (1) what <em>actually</em> happened, (2) what counterfactually <em>might have</em> happened, but did not, and (3) what <em>could not</em> have happened. Pushing forward through <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math> illustrates this well. If the input play is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> then what actually happens is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, h)</annotation></semantics></math>, what could have happened is any element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Δ</mi><mo>*</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Delta^* (X) = \{ (x, x) \mid x \in X \}</annotation></semantics></math>, and any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, x')</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≠</mo><msup><mi>x</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">x \neq x'</annotation></semantics></math> could not have happened even counterfactually.</p>
<p>This motivates the following definition. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>:</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">T : \mathbf{Set} \to \mathbf{Set}</annotation></semantics></math> be given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo>⊆</mo><mi>X</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">T (X) = \{ (x, S) \mid x \in S \subseteq X \}</annotation></semantics></math>. I call T the <em>pointed powerset monad</em>, and it is a hybrid of the identity and powerset monads. The monad unit is given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\eta (x) = (x, \{ x \})</annotation></semantics></math>, and the multiplication by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msup><mi>S</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mo>⋃</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mu ((x, S'), S) = (x, \bigcup S)</annotation></semantics></math>. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> admits monad morphisms to both identity and powerset. The kleisli category of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is “pointed relations”: a kleisli morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math> is a relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \subseteq X \times Y</annotation></semantics></math> together with a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> satisfying <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x, f (x)) \in R</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> is commutative, its kleisli category <a href="../posts/2019-04-18-folklore-monoidal-kleisli-categories.html">admits a monoidal product</a>. (I’ve never seen this monad before in the literature.)</p>
<p>Fortunately we can save some work and <em>hack</em> this monad in Haskell by pretending that ordinary lists are pointed subsets, using the head as the basepoint. Nothing goes wrong as long as we are careful to only use lists in ways that are invariant under permutation and duplication (ie. we treat free monoids in ways that are also valid for free commutative idempotent monoids). All of the list monad operations are “head-preserving” in the appropriate way.</p>
<p>Just as for Bayesian open games, we set up <a href="https://arxiv.org/abs/1809.00738">coend optics</a> for the kleisli category of this monad. In category theoretic notation a kleisli optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, S) \to (Y, R)</annotation></semantics></math> is an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mi>A</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>→</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>T</mi><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int^A (X \to T (A \times Y)) \times (A \times R \to T S)</annotation></semantics></math>, and in Haskell notation it is an element of the GADT</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Optic</span> x s y r <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Optic</span><span class="ot"> ::</span> (x <span class="ot">-&gt;</span> [(a, y)]) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> [s]) <span class="ot">-&gt;</span> <span class="dt">Optic</span> x s y r</span></code></pre></div>
<p>The type of contexts is also exactly as for Bayesian open games: it is an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mi>A</mi></msup><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>T</mi><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int^A T (A \times X) \times (A \times Y \to T R)</annotation></semantics></math> or</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Context</span> x s y r <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Context</span><span class="ot"> ::</span> [(a, x)] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> y <span class="ot">-&gt;</span> [r]) <span class="ot">-&gt;</span> <span class="dt">Context</span> x s y r</span></code></pre></div>
<p>The definition of the monoidal category of open games can be done generically for an arbitrary monad, so almost all of the code follows for free.</p>
<p>The <em>only</em> thing that needs to be specialised to the pointed powerset monad is the definition of a decision <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒟</mi><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D} : (X, 1) \to (Y, \mathbb{R})</annotation></semantics></math>. This isn’t trivial. The set of strategies is still <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mi>𝒟</mi></msub><mo>=</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\Sigma_{\mathcal{D}} = X \to Y</annotation></semantics></math>. For a strategy <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\sigma : X \to Y</annotation></semantics></math> we must produce an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, 1) \to (Y, \mathbb{R})</annotation></semantics></math>. We take the bound variable to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A = 1</annotation></semantics></math>, so the backward part is trivial and we need only give the view <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>T</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">v : X \to T Y</annotation></semantics></math>. We take <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">v (x) = (\sigma (x), Y)</annotation></semantics></math>, the pointed subset <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y \subseteq Y</annotation></semantics></math> with basepoint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma (x)</annotation></semantics></math>. This means that what happens is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma (x)</annotation></semantics></math>, but any element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> could happen counterfactually, because the agent has a free choice. (This is an unusually clear appearance of <em>free will</em> in mathematics.)</p>
<p>In Haskell I always write decisions to take an exhaustive list of possible moves as a parameter in order to brute force <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>arg</mi><mo>⁡</mo></mrow><mi>max</mi></mrow><annotation encoding="application/x-tex">\arg\max</annotation></semantics></math>, because implementing a decent <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>arg</mi><mo>⁡</mo></mrow><mi>max</mi></mrow><annotation encoding="application/x-tex">\arg\max</annotation></semantics></math> is an orthogonal problem. So the implementation of a decision begins:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decision ::</span> [y] <span class="ot">-&gt;</span> <span class="dt">OG</span> (x <span class="ot">-&gt;</span> y) x () y <span class="dt">Double</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>decision ys <span class="ot">=</span> <span class="dt">OG</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  play <span class="ot">=</span> \f <span class="ot">-&gt;</span> <span class="kw">let</span> v x <span class="ot">=</span> <span class="fu">zip</span> (<span class="fu">repeat</span> ()) (f x <span class="op">:</span> ys)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                   u () _ <span class="ot">=</span> [()]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">in</span> <span class="dt">Optic</span> v u</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>Here <code>f x : ys</code> is the list representing the pointed subset <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f (x), Y)</annotation></semantics></math>.</p>
<p>Finally, we must evaluate a strategy <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">\sigma : X \to Y</annotation></semantics></math> in a context, which is a triple <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>h</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, h, k)</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>×</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h : T (A \times X)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>A</mi><mo>×</mo><mi>Y</mi><mo>→</mo><mi>T</mi><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">k : A \times Y \to T \mathbb{R}</annotation></semantics></math>. Here we get right to the heart of what subgame perfection is all about: we ignore the factual part of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> and only use the set of counterfactuals, but we ignore the counterfactual part of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> and only use the factual. Specifically, the equilibrium condition is that for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">(a, x) \in h</annotation></semantics></math>, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mrow><mi>arg</mi><mo>⁡</mo></mrow><msub><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow></msub><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><msub><mo stretchy="false" form="postfix">)</mo><mo>*</mo></msub></mrow><annotation encoding="application/x-tex">\sigma (x) \in \arg\max_{y \in Y} k (a, y)_*</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><msub><mo stretchy="false" form="postfix">)</mo><mo>*</mo></msub></mrow><annotation encoding="application/x-tex">k (a, y)_*</annotation></semantics></math> means the basepoint of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>T</mi><mi>ℝ</mi></mrow><annotation encoding="application/x-tex">k (a, y) : T \mathbb{R}</annotation></semantics></math>. Information about <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is transferred to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> via <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, which is <em>entangled</em> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in the state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>.</p>
<p>In Haskell, the definition concludes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  equilibrium <span class="ot">=</span> \(<span class="dt">Context</span> h k) f <span class="ot">-&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">and</span> [<span class="fu">head</span> (k a (f x)) <span class="op">&gt;=</span> <span class="fu">head</span> (k a y) <span class="op">|</span> (a, x) <span class="ot">&lt;-</span> h, y <span class="ot">&lt;-</span> ys]}</span></code></pre></div>
<p>And that’s it! I have no intention to <em>prove</em> that this always gives subgame perfect equilibrium any time soon – correctness proofs for open games are always extremely painful (they go by induction on extensive form) and I put them off as long as I realistically can. It passes the <a href="https://en.wikipedia.org/wiki/Ultimatum_game">ultimatum game</a> test, which is illustrated in <a href="https://github.com/CyberCat-Institute/open-game-engine/blob/og-v0.1/src/OpenGames/Examples/SubgameTest.hs">OpenGames.Examples.SubgameTest</a>. For me this is enough evidence to start using it first and ask questions later.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
