<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Bidirectional typechecking is bidirectional</title>
        <link rel="stylesheet" href="../css/edited.css" />
        <link rel="stylesheet" href="../css/fonts.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Bidirectional typechecking is bidirectional</h1>
            <article>
    <section class="header">
        Posted on January 28, 2025
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2025/01/28/bidirectional-typechecking/">X-posted on the CyberCat Institute blog</a>)</p>
<p>For a while I’ve had an intuition that typechecking should be optical, with subterms going forwards and types (and type errors) for subterms going backwards. In this post I’ll make sense of this idea, by implementing a bidirectional typechecker for simply typed lambda calculus as an optic, using Haskell’s <code>Control.Lens</code>.</p>
<p>There is basically nothing here that is specialised to typechecking, bidirectional or otherwise, it is merely a neat and well-specified example of a tree search problem and makes for a funny title. This is a hammer I’ve been weighing up for quite a long time for a wide variety of applications. One fun thing I want to work out as a proof of concept is scripting NPC AI for videogames, or as I put it for the meme, “Metal Gear Solid is lenses” (stealth games being an example where the AI behaving realistically is more important than usual).</p>
<h2 id="bidirectionally-typed-stlc">Bidirectionally typed STLC</h2>
<p>The starting point of bidirectional typechecking is to partition the terms of the language into two classes, the <em>synthesisable</em> terms (whose type can be algorithmically inferred) and <em>checkable</em> terms (whose type can be algorithmically checked). In STLC, a term that is a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is synthesisable, an application <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">tu</annotation></semantics></math> is synthesisable when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> is synthesisable and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> is checkable, and an abstraction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x . t</annotation></semantics></math> is checkable when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> is checkable (note that the abstracted variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> does not carry a type annotation, unlike in some presentations of STLC). Also, any synthesisable term can be considered as checkable, and any checkable term can be considered as synthesisable if paired with a type annotation.</p>
<p>In Haskell this is nothing fancy:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span> <span class="ot">=</span> <span class="dt">TVar</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Unit</span> <span class="op">|</span> <span class="dt">Function</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TermSyn</span> <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">App</span> <span class="dt">TermSyn</span> <span class="dt">TermChk</span> <span class="op">|</span> <span class="dt">Down</span> <span class="dt">Type</span> <span class="dt">TermChk</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TermChk</span> <span class="ot">=</span> <span class="dt">Lambda</span> <span class="dt">String</span> <span class="dt">TermChk</span> <span class="op">|</span> <span class="dt">Up</span> <span class="dt">TermSyn</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>Let’s write the rules of bidirectional STLC in traditional programming languages notation. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> is a synthesisable term and synthesising its type returns the result <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> then we write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">t \in a</annotation></semantics></math>. If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> is a checkable term and we successfully check that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> then we write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∋</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">a \ni t</annotation></semantics></math>. (The symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∋</mo><annotation encoding="application/x-tex">\ni</annotation></semantics></math> is pronounced “ni”, and also written that way in LaTeX/MathJax, hence the paper <a href="https://github.com/pigworker/TypesWhoSayNi/blob/master/tex/TypesWhoSayNi.pdf">The Types Who Say Ni</a> by Conor Mc Bride.) We also say “the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> accepts the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>”.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>a</mi><mo>⊢</mo><mi>x</mi><mo>∈</mo><mi>a</mi></mrow></mfrac><mtext mathvariant="normal">(Var)</mtext></mrow><annotation encoding="application/x-tex"> \frac{}{\displaystyle \Gamma, x : a \vdash x \in a}\text{(Var)} </annotation></semantics></math></p>
<ul>
<li>To synthesise the type of a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> we simply look it up in the context and return what the context says its type is</li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>∈</mo><mi>a</mi><mo>→</mo><mi>b</mi><mspace width="2.0em"></mspace><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>∋</mo><mi>u</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mi>u</mi><mo>∈</mo><mi>b</mi></mrow></mfrac><mtext mathvariant="normal">(App)</mtext></mrow><annotation encoding="application/x-tex"> \frac{\displaystyle \Gamma \vdash t \in a \to b \qquad \Gamma \vdash a \ni u}{\displaystyle \Gamma \vdash tu \in b}\text{(App)} </annotation></semantics></math></p>
<ul>
<li>To synthesise the type of an application <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">tu</annotation></semantics></math>, we synthesise the type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, find that the result is a function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math>, check that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, and return <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>a</mi><mo>⊢</mo><mi>b</mi><mo>∋</mo><mi>t</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>→</mo><mi>b</mi><mo>∋</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow></mfrac><mtext mathvariant="normal">(Lam)</mtext></mrow><annotation encoding="application/x-tex"> \frac{\displaystyle \Gamma, x : a \vdash b \ni t}{\displaystyle \Gamma \vdash a \to b \ni \lambda x . t}\text{(Lam)} </annotation></semantics></math></p>
<ul>
<li>To check that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\lambda x . t</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math>, we check that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> after extending the context with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x : a</annotation></semantics></math></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>∋</mo><mi>t</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo>↓</mo><mi>t</mi><mo>:</mo><mi>a</mi><mo>∈</mo><mi>a</mi></mrow></mfrac><mtext mathvariant="normal">(Down)</mtext></mrow><annotation encoding="application/x-tex"> \frac{\displaystyle \Gamma \vdash a \ni t}{\displaystyle \Gamma \vdash \downarrow t : a \in a}\text{(Down)} </annotation></semantics></math></p>
<ul>
<li>To synthesise the type of a coerced checkable term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> paired with a type annotation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, we check that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, then return <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math></li>
</ul>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>t</mi><mo>∈</mo><mi>b</mi><mspace width="2.0em"></mspace><mi>a</mi><mo>=</mo><mi>b</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>a</mi><mo>∋</mo><mo>↑</mo><mi>t</mi></mrow></mfrac><mtext mathvariant="normal">(Up)</mtext></mrow><annotation encoding="application/x-tex"> \frac{\displaystyle \Gamma \vdash t \in b \qquad a = b}{\displaystyle \Gamma \vdash a \ni \uparrow t}\text{(Up)} </annotation></semantics></math></p>
<ul>
<li>To check that a coerced synthesisable term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>, we synthesise the type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> and make sure that the result is equal to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math></li>
</ul>
<h2 id="questions-and-answers">Questions and answers</h2>
<p>To arrange all of this into an optic, we need to go back to one of the earliest ideas for using lens-like things in strange ways, in <a href="https://arxiv.org/abs/math/9309208">this classic paper by Blass</a>, which is to have a boundary made of questions and answers. We ask an optic a question, it can in turn ask questions on its opposite boundary, it receives answers, and then finally it answers to us. The questions we can ask here are “what is the type of this synthesisable term?” and “does this checkable term have this type?”:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Context</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Type</span>)]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Question</span> <span class="ot">=</span> <span class="dt">Synthesise</span> <span class="dt">Context</span> <span class="dt">TermSyn</span> <span class="op">|</span> <span class="dt">Check</span> <span class="dt">Context</span> <span class="dt">Type</span> <span class="dt">TermChk</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Answer</span> <span class="ot">=</span> <span class="dt">Synthesised</span> <span class="dt">Type</span> <span class="op">|</span> <span class="dt">Checked</span> <span class="op">|</span> <span class="dt">TypeError</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>For now I have here chosen that “type error” carries no additional information, but the question of how best to handle the sad path is one we’ll come back to later because it creates a tension between theory and implementation.</p>
<p>Here is an example of how such a “question-and-answer protocol” is implemented using a functor lens in Haskell, illustrated using the (Lam) rule:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lam ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (<span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span>) <span class="ot">-&gt;</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lam k (<span class="dt">Check</span> ctx (<span class="dt">Function</span> a b) (<span class="dt">Lambda</span> x t)) <span class="ot">=</span> k (<span class="dt">Check</span> ((x, a) <span class="op">:</span> ctx) b t)</span></code></pre></div>
<p>I find the CPS-like van Laarhoven representation helpful here (for once!) by reflecting the protocol directly. We ask the lens the question <code>Check ctx (Function a b) (Lambda x t)</code>, it asks its continuation the question <code>Check ((x, a) : ctx) b t</code>, it gets back the answer, and then it returns the answer to us unchanged.</p>
<p>There is a very obscure but very useful bit of intuition that I learned from Bob Atkey in <a href="https://www.youtube.com/watch?v=YpklMn5yNA0">this seminar</a>, which is that superclasses of Lens differ in the quantity that they have access to their continuation. A lens must call its continuation exactly once, an affine traversal can call its continuation at most once, and a traversal can call its continuation any finite number of times. In the van Laarhoven encoding, a lens must call its continuation at least once because there is no other way to get a value in the unknown functor <code>f</code>, and there is also no way to combine the result of two different calls so it can only return one of them. For affine traversals we use pointed functors, which allow us to get into the functor without calling the continuation but still do not allow us to combine the result from two different calls. For traversals we use applicatives, which do both.</p>
<p>All this is to say, I <em>expected</em> the (App) rule, which has 2 hypotheses, to be a Traversal, ie. something with type</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (<span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span>) <span class="ot">-&gt;</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span></span></code></pre></div>
<p>But when I came to write it, I reached an unexpected subtlety. Traversals can call their continuation any number of times, but those calls must be <em>independent</em>. The (App) rule, which must answer the question “what is the type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">tu</annotation></semantics></math>?”, first asks the question “what is the type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>?”, and then upon receiving the answer “<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>”, it asks the followup question “does <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> have type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>?”. That is, the second question depends on the first answer, and this is something that is not possible with a Traversal.</p>
<h2 id="monadic-traversals">Monadic traversals</h2>
<p>The type signature needed to express the (App) rule is something that, at first sight, looks like an extremely obvious superclass of Traversals:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Monad</span> f) <span class="ot">=&gt;</span> (<span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span>) <span class="ot">-&gt;</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>app k (<span class="dt">Synthesise</span> ctx (<span class="dt">App</span> t u)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Synthesised</span> (<span class="dt">Function</span> a b) <span class="ot">&lt;-</span> k (<span class="dt">Synthesise</span> ctx t)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Checked</span> <span class="ot">&lt;-</span> k (<span class="dt">Check</span> ctx a u)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Synthesised</span> b)</span></code></pre></div>
<p>The appearance of <code>a</code> on the second line of the <code>do</code> block is exactly the thing that can’t be done with an Applicative.</p>
<p>This class of optics apparently has no name, although I few people have suggested the idea. I already use the terms “monadic lens” and “monadic optic” already (respectively for <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/mlenses.pdf">lenses whose backward pass is in a kleisli category</a> and <a href="https://compositionality.episciences.org/13528">monoidal optics entirely in a kleisli category</a>) - I like Zanzi’s suggestion to call this a <em>monadic traversal</em>. <a href="https://www.reddit.com/r/haskell/comments/cak4kh/missing_lenslike_type_alias/">Apparently there are no nontrivial examples of lawful monadic traversals</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, that is to say, every monadic traversal satisfying the traversal laws is already an ordinary traversal. Fortunately, my entire career has been spent spitting in the face of the optic laws. More to the point, I’m fairly sure these question-and-answer optics can <em>never</em> be meaningfully lawful even in the most generalised sense, because an answer does not determine a canonical followup question, but they are still extremely important for many applications.</p>
<p>I conjecture that the optic</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MonadicTraversal</span> s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">Monad</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span></code></pre></div>
<p>is isomorphic to this concrete implementation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MonadicTraversal</span> s t a b <span class="ot">=</span> s <span class="ot">-&gt;</span> <span class="dt">Interaction</span> a b t</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Interaction</span> a b t <span class="ot">=</span> <span class="dt">Done</span> t</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                       <span class="op">|</span> <span class="dt">More</span> a (b <span class="ot">-&gt;</span> <span class="dt">Interaction</span> a b t)</span></code></pre></div>
<p>An <code>Interaction a b t</code> can either terminate with an answer of type <code>t</code>, or it can ask a question of type <code>a</code>, and for each answer (of type <code>b</code>) it has a “continuation interaction”. This is the equivalent for monadic traversals of what for ordinary traversals is called a <a href="https://twanvl.nl/blog/haskell/non-regular1">FunList</a> (also known as a Bazaar in its functor encoding).</p>
<h2 id="putting-it-together">Putting it together</h2>
<p>With all this setup, here is the full implementation of a typechecker as a monadic traversal:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> <span class="dt">MonadicTraversal</span> <span class="dt">Question</span> <span class="dt">Answer</span> <span class="dt">Question</span> <span class="dt">Answer</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>rules _ (<span class="dt">Synthesise</span> ctx (<span class="dt">Var</span> x)) <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> x ctx <span class="kw">of</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Synthesised</span> a)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Synthesise</span> ctx (<span class="dt">App</span> t1 t2)) <span class="ot">=</span> k (<span class="dt">Synthesise</span> ctx t1) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Synthesised</span> (<span class="dt">Function</span> a b) <span class="ot">-&gt;</span> k (<span class="dt">Check</span> ctx a t2) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Checked</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Synthesised</span> b)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Synthesise</span> ctx (<span class="dt">Down</span> a t)) <span class="ot">=</span> k (<span class="dt">Check</span> ctx a t) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Checked</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Synthesised</span> a)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Check</span> ctx (<span class="dt">Function</span> a b) (<span class="dt">Lambda</span> x t)) <span class="ot">=</span> k (<span class="dt">Check</span> ((x, a) <span class="op">:</span> ctx) b t)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>rules _ (<span class="dt">Check</span> _ _ (<span class="dt">Lambda</span> _ _)) <span class="ot">=</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Check</span> ctx a (<span class="dt">Up</span> t)) <span class="ot">=</span> k (<span class="dt">Synthesise</span> ctx t) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Synthesised</span> b <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="op">==</span> b <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Checked</span> <span class="kw">else</span> <span class="fu">return</span> <span class="dt">TypeError</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError</span></span></code></pre></div>
<p>This optic implements typechecking provided it is post-composed with another optic that implements typechecking for subterms. Any actual lambda term has subterms nested finitely but arbitrarily deep, so what we need to do is to compose this optic with itself and take a fixpoint, remembering that van Laarhoven encoded optics compose by reverse function composition:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stlc ::</span> <span class="dt">MonadicTraversal</span> <span class="dt">Question</span> <span class="dt">Answer</span> <span class="dt">Question</span> <span class="dt">Answer</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>stlc <span class="ot">=</span> rules <span class="op">.</span> stlc</span></code></pre></div>
<p>Personally I find this infinite composition chain surprisingly similar to the way we implemented <a href="https://cgi.cse.unsw.edu.au/~eptcs/paper.cgi?ACT2022.24">Bellman iteration as optic composition</a>.</p>
<p>Now we can write a typechecker by calling this lenses using standard <code>Control.Lens</code> combinators:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> <span class="dt">Answer</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>typecheck q <span class="ot">=</span> q <span class="op">&amp;</span> stlc <span class="op">.~</span> <span class="dt">TypeError</span></span></code></pre></div>
<p>And this works! Here is what it looks like running on the lambda term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">(\lambda y . y) x</annotation></semantics></math> in the context <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x : a</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> typecheck <span class="op">$</span> <span class="dt">Synthesise</span> [(<span class="st">&quot;x&quot;</span>, <span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>)] </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                <span class="op">$</span> <span class="dt">App</span> (<span class="dt">Down</span> (<span class="dt">Function</span> (<span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>) (<span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">Lambda</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Up</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)))) </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                      (<span class="dt">Up</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Synthesised</span> (<span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>)</span></code></pre></div>
<p>The backward input <code>TypeError</code> in the function <code>typecheck</code>, which comes at the end of the infinite composition chain, is never actually used: we only go as far down the chain as the subterm depth of our lambda term before returning. It can be changed to <code>undefined</code> and everything still works correctly. This is almost exactly what happens with Bellman iteration with lenses, where the backward input is an arbitrary real number that gets infinitely discounted to zero.</p>
<h2 id="handling-the-sad-path">Handling the sad path</h2>
<p>In theory we are done, but in practice we are handling type errors in a very bad way: about half of the implementation is handling type errors, and despite this we are still collapsing all type errors to a single value instead of returning any useful information to the caller.</p>
<p>Just for fun, here is an idea I had that fixes the first problem while ignoring the second, by heavily abusing how Haskell desugars do-notation. There is a class in Prelude called <code>MonadFail</code> that exists for legacy reasons, and adds to the monad signature a function <code>fail :: String -&gt; m a</code>. When Haskell encounters certain syntactic forms of possibly-failing pattern match in a <code>do</code>-block, it desugars it to <code>MonadFail</code>, filling the string with information about the failed match.</p>
<p>Any reader who was unhappy about monadic traversals should probably skip the next block of code, because I am about to deploy an optic for <code>MonadFail</code>. It’s fair to say that this is one of the more horrifying things I have ever done in Haskell.</p>
<p>The caveat is that this “feature” appears to be only half finished, or maybe more likely has only been half removed: pattern matches on the left of a <code>&lt;-</code> desugar to <code>fail</code>, but pattern matches in a <code>let</code> form instead desugar to <code>Prelude.error</code>. So we have to transform <code>let x = y</code> into <code>x &lt;- return y</code> for this to work.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rules ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">MonadFail</span> f) <span class="ot">=&gt;</span> (<span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span>) <span class="ot">-&gt;</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>rules _ (<span class="dt">Synthesise</span> ctx (<span class="dt">Var</span> x)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a <span class="ot">&lt;-</span> <span class="fu">return</span> (<span class="fu">lookup</span> x ctx) </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">Synthesised</span> a)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Synthesise</span> ctx (<span class="dt">App</span> t u)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Synthesised</span> (<span class="dt">Function</span> a b) <span class="ot">&lt;-</span> k (<span class="dt">Synthesise</span> ctx t)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Checked</span> <span class="ot">&lt;-</span> k (<span class="dt">Check</span> ctx a u)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">Synthesised</span> b)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Synthesise</span> ctx (<span class="dt">Down</span> a t)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Checked</span> <span class="ot">&lt;-</span> k (<span class="dt">Check</span> ctx a t)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">Synthesised</span> a)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Check</span> ctx a (<span class="dt">Lambda</span> x t)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Function</span> b c <span class="ot">&lt;-</span> <span class="fu">return</span> a</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    k (<span class="dt">Check</span> ((x, b) <span class="op">:</span> ctx) c t)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>rules k (<span class="dt">Check</span> ctx a (<span class="dt">Up</span> t)) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Synthesised</span> b <span class="ot">&lt;-</span> k (<span class="dt">Synthesise</span> ctx t)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> a <span class="op">==</span> b <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Checked</span> </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>              <span class="kw">else</span> <span class="fu">fail</span> <span class="op">$</span> <span class="fu">unwords</span> [<span class="st">&quot;Could not match&quot;</span>, <span class="fu">show</span> a, <span class="st">&quot;and&quot;</span>, <span class="fu">show</span> b]</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="ot">stlc ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="dt">MonadFail</span> f) <span class="ot">=&gt;</span> (<span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span>) <span class="ot">-&gt;</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> f <span class="dt">Answer</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>stlc <span class="ot">=</span> rules <span class="op">.</span> stlc</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheck ::</span> <span class="dt">Question</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Answer</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>typecheck <span class="ot">=</span> stlc (<span class="fu">const</span> <span class="dt">Nothing</span>)</span></code></pre></div>
<p>The last part of this is using the fact that <code>Maybe</code> has a builtin instance of <code>MonadFail</code> (which ignores the error string).</p>
<p>Back in the world of actual engineering instead of memeing, my best idea for the right way to deal with the unhappy path is to define a <code>TypeError</code> type, which can be as informative as we want, and use an optic for <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Except.html">the class</a> <code>Control.Monad.Except.MonadError TypeError</code> from <code>mtl</code>. And, obviously, we do the work of explicitly detecting and throwing informative type errors instead of the preceeding silliness. I haven’t actually built it because I’m not entirely convinced that optics for a class from <code>mtl</code> is <em>actually</em> a good idea, but so far I do not have any better ideas.</p>
<h2 id="pipelines">Pipelines</h2>
<p>Recently <a href="https://cybercat.institute/2025/01/13/program-pipelines.idr/">André wrote a post about compiler pipelines</a>, and is working on a followup post doing the same thing with lenses. For example, typechecking is one stage of a compiler pipeline that is preceeded by scopechecking and is followed by code generation.</p>
<p>What I have done in this post throws a spanner into that, because I am using optics that are infinite composition chains that never actually reach their codomain boundary, so it doesn’t make sense to compose them end-to-end.</p>
<p>My gut feeling is that there should be some (asymmetric) monoidal product on traversals that is the one true way of sequencing things defined in this way. But I haven’t found it yet, so instead I’m going to show something that works but I don’t think is <em>right</em>.</p>
<p>Suppose as well as typechecking we have another monadic traversal of this type:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ScopeCheckQuestion</span> <span class="ot">=</span> <span class="dt">ScopeCheckQuestion</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ScopeCheckAnswer</span> <span class="ot">=</span> <span class="dt">WellScoped</span> <span class="op">|</span> <span class="dt">ScopeError</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">scopecheck ::</span> <span class="dt">MonadicTraversal</span> <span class="dt">ScopeCheckQuestion</span> <span class="dt">ScopeCheckAnswer</span> </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">ScopeCheckQuestion</span> <span class="dt">ScopeCheckAnswer</span></span></code></pre></div>
<p>We need to take the coproduct of the scopechecking and typechecking traversals. Coproducts of optics require dependent types to write correctly, but here is the closest we can get in Haskell, with possibly-failing pattern matches that the type is unable to rule out:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plus ::</span> (<span class="dt">Functor</span> f)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t) <span class="ot">-&gt;</span> ((a' <span class="ot">-&gt;</span> f b') <span class="ot">-&gt;</span> s' <span class="ot">-&gt;</span> f t')</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> (<span class="dt">Either</span> a a' <span class="ot">-&gt;</span> f (<span class="dt">Either</span> b b') <span class="ot">-&gt;</span> <span class="dt">Either</span> s s' <span class="ot">-&gt;</span> f (<span class="dt">Either</span> t t'))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>plus l _ k (<span class="dt">Left</span> s) <span class="ot">=</span> <span class="dt">Left</span> <span class="op">&lt;$&gt;</span> l (\a <span class="ot">-&gt;</span> <span class="fu">fmap</span> (\(<span class="dt">Left</span> s) <span class="ot">-&gt;</span> s) (k (<span class="dt">Left</span> a))) s</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>plus _ l' k (<span class="dt">Right</span> s') <span class="ot">=</span> <span class="dt">Right</span> <span class="op">&lt;$&gt;</span> l' (\a' <span class="ot">-&gt;</span> <span class="fu">fmap</span> (\(<span class="dt">Right</span> s') <span class="ot">-&gt;</span> s') (k (<span class="dt">Right</span> a'))) s' </span></code></pre></div>
<p>Now we can precompose this with a monadic traversal that calls the two parts in the right order:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OverallAnswer</span> <span class="ot">=</span> <span class="dt">ScopeError'</span> <span class="op">|</span> <span class="dt">TypeError'</span> <span class="op">|</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pipeline ::</span> <span class="dt">MonadicTraversal</span> (<span class="dt">Context</span>, <span class="dt">TermSyn</span>) </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">OverallAnswer</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                             (<span class="dt">Either</span> <span class="dt">ScopeCheckQuestion</span> <span class="dt">Question</span>) </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                             (<span class="dt">Either</span> <span class="dt">ScopeCheckAnswer</span> <span class="dt">Answer</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>pipeline k (ctx, t) <span class="ot">=</span> k (<span class="dt">Left</span> <span class="dt">ScopeCheckQuestion</span>) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> <span class="dt">ScopeError</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">ScopeError'</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> <span class="dt">WellScoped</span> <span class="ot">-&gt;</span> k (<span class="dt">Right</span> (<span class="dt">Synthesise</span> ctx t)) <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> <span class="dt">TypeError</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">TypeError'</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> (<span class="dt">Synthesised</span> a) <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Type</span> a)</span></code></pre></div>
<p>I’m not quite happy with this, even after putting the missing dependent types back in, but it does work. I’m going to leave it for the future to find a more canonical way to sequence pipeline steps.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Thanks to <a href="https://x.com/effectfully/status/1878963740525162556"><span class="citation" data-cites="effectfully">@effectfully</span> on twitter</a> for this link<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
