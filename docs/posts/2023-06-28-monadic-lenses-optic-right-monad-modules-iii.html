<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Monadic lenses are the optic for right monad modules III</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Monadic lenses are the optic for right monad modules III</h1>
            <article>
    <section class="header">
        Posted on June 28, 2023
        
    </section>
    <section>
        <p>This post picks up where the <a href="../posts/2023-06-07-monadic-lenses-optic-right-monad-modules-i.html">exposition in the first installment</a> left off, before the sideline <a href="../posts/2023-06-24-monadic-lenses-optic-right-monad-modules-ii.html">development in the second installment</a>. I never intended to make a blog post in <a href="https://en.wikipedia.org/wiki/Sonata_form">sonata form</a>, but there we are. Code for this post can be found <a href="https://github.com/CyberCat-Institute/cybercat-core/blob/master/src/Cybercat/Sketches/MonadicOptic.hs">here</a>.</p>
<p>If we’d like both our forwards and backwards passes to live in our monad then this is the simplest case that there is no possible concrete description, without using any quantification. If we naively put the monad on both the forwards and backwards passes, so we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>m</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">s \to m a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>×</mo><mi>b</mi><mo>→</mo><mi>m</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">s \times b \to m t</annotation></semantics></math>, it even looks like we can compose them, but it’s a trap: this composition law completely fails to be associative for virtually all monads of interest. <a href="../posts/2018-01-16-towards-compositional-game-theory.html">I fell into this exact trap in my PhD thesis</a>, which also flew by my examiners until it was caught by my former PhD student Joe Bolt.</p>
<p>The solution, which is the main topic of <a href="https://arxiv.org/abs/1809.00738">Mitchell Riley’s important paper</a>, is to use coend optics in the kleisli category. Using this to repair my thesis eventually led to the paper <a href="https://arxiv.org/abs/1910.03656">Bayesian Open Games</a>, which went on to be <a href="https://20squares.xyz/">by far the most useful version of open games in practice</a>. The motivation behind this post is to use my “<a href="../posts/2023-01-14-making-haskell-lenses-less-pointless.html">less pointless lenses</a>” trick with the “<a href="https://arxiv.org/abs/2206.12338">diegetic</a>” variant of Bayesian open games in order to get a domain specific language written directly in native Haskell rather than compiled via templates, which would have several practical advantages. This is one of several steps needed to get to that point.</p>
<p>The way to define a lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(s, t) \to (a, b)</annotation></semantics></math> for which both the forwards and backwards passes live in the monad <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> is</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b <span class="ot">=</span> exists z<span class="op">.</span> (s <span class="ot">-&gt;</span> m (a, z), z <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m t)</span></code></pre></div>
<p>These don’t have an agreed name, but I usually call them “monadic optics” or “kleisli optics”. The intuitive idea is that in the non-cartesian world of the monad, the existentially bound variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> can ‘entangle’ the forwards and backwards passes. In Haskell this is easiest to encode as a GADT:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ExistentialKleisliOptic</span><span class="ot"> ::</span> (s <span class="ot">-&gt;</span> m (a, z)) <span class="ot">-&gt;</span> (z <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m t) <span class="ot">-&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b</span></code></pre></div>
<p>The reason this encoding is pointless is that it can’t be rewritten in the form of a function from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> to something, unlike van Laarhoven lenses which can.</p>
<p>Until now I’ve always worked directly with the existential encoding. For example, we can define composition directly:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> (<span class="dt">Monad</span> m)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m a b o p</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m s t o p</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>(<span class="dt">ExistentialKleisliOptic</span> g1 p1) <span class="op">&gt;&gt;&gt;</span> (<span class="dt">ExistentialKleisliOptic</span> g2 p2)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">ExistentialKleisliOptic</span> (\s <span class="ot">-&gt;</span> <span class="kw">do</span> (a, z1) <span class="ot">&lt;-</span> g1 s</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                                      (o, z2) <span class="ot">&lt;-</span> g2 a</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                                      <span class="fu">pure</span> (o, (z1, z2)))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                            (\(z1, z2) p <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> p2 z2 p</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                                               p1 z1 b)</span></code></pre></div>
<p>The question is how to encode them in van Laarhoven style. Unlike in <a href="../posts/2023-06-07-monadic-lenses-optic-right-monad-modules-i.html">the first post</a> for monadic lenses, in this post I’m going to pull the solution from my hat because I don’t understand it well enough to guide the reader through inventing it. To encode kleisli optics as a van Laarhoven lens, we need two constraints on our functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>:</p>
<ul>
<li>Just as for monadic lenses, we need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to be a right module of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>, that is, we need a natural transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>f</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">f (m a) \to f a</annotation></semantics></math> compatible with the structure of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math></li>
<li>We need a distributive law of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, that is, a natural transformation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">m (f a) \to f (m a)</annotation></semantics></math> compatible with the structure of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math></li>
</ul>
<p>These either should or shouldn’t interact with the structure that was the topic of <a href="../posts/2023-06-24-monadic-lenses-optic-right-monad-modules-ii.html">the previous post</a>, a distributive bimodule – I don’t know yet, but the code works the same either way.</p>
<p>Recall that we have defined right modules and distributive laws:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">RightModule</span> m f <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    act ::</span> f (m a) <span class="ot">-&gt;</span> f a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Distributive</span> m f <span class="kw">where</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    distribute ::</span> m (f a) <span class="ot">-&gt;</span> f (m a)</span></code></pre></div>
<p>We define kleisli optics in van Laarhoven style as the optic for these constraints:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">KleisliOptic</span> m s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Functor</span> f, <span class="dt">RightModule</span> m f, <span class="dt">Distributive</span> m f)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f s t a b</span></code></pre></div>
<p>We need to define the equivalence between the existential and van Laarhoven representations. To go from existential to vL we work with these constraints polymorphically. To go the other way, we need to come up with a specific distributive right module that does the trick.</p>
<p>Ok, let’s walk through how to convert from an existential kleisli optic to a van Laarhoven one, by type directed programming. Our existential keisli optic unpacks to a pair of a get map <code>g :: s -&gt; m (a, z)</code> and a put map <code>p :: z -&gt; b -&gt; m t</code>, where <code>z</code> is some existentially bound type. We also have a continuation <code>k :: a -&gt; f b</code> where <code>f</code> is some functor that is equipped with a right action <code>act :: f (m x) -&gt; f x</code> and a distributive law <code>distribute :: m (f x) -&gt; f (m x)</code>. We also have an input <code>s</code>, and our goal is to produce an <code>f t</code>.</p>
<p>Let’s immediately make the guess that the last thing we do is to apply the action, which means instead we need to produce an <code>f (m t)</code>.</p>
<p>Our next thought might be that the next-last thing to do is to apply the distributive law (which means, secretly, we’re ending with the left action given by the distributive law and right action). That would mean that we need to make an <code>m (f t)</code>. It turns out though that we can’t get there. If we now go into do-notation, we can get <code>(a, z)</code> from <code>g s</code>. But then from the <code>a</code> we get an <code>f b</code>. But then <code>fmap (p z)</code> has type <code>f b -&gt; f (m t)</code>, and we can no longer get back into the monad – we need to use the distributive law on the other side. What we need to do is thread the residual <code>z</code> past the distributive law in a more subtle way.</p>
<p>Let’s go from the other end. Within do-notation we can get <code>(a, z)</code> from <code>g s</code>. Now we can get <code>k a :: f b</code>. Since we have <code>z</code>, we can insert it using <code>fmap (z, ) (k a) :: f (z, b)</code>. Stepping back out of the monad, this gives us a subterm of type <code>m (f (b, z))</code>,</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> (a, z) <span class="ot">&lt;-</span> g s</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">pure</span> (<span class="fu">fmap</span> (, z) (k a))</span></code></pre></div>
<p>Let’s apply the distributive law to this, so it becomes of type <code>f (m (z, b))</code>. We’re still aiming for <code>f (m t)</code> so we can end with the action, and we can get there with <code>fmap</code> if we can make a function of type <code>m (z, b) -&gt; m t</code>. And we can indeed do that – it’s basically the kleisli extension of the put map <code>p :: z -&gt; b -&gt; m t</code>. The slick way to write it is as an operator section <code>(&gt;&gt;= (uncurry p))</code>.</p>
<p>And that’s it! The function we built is this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">kleisliOptic ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b <span class="ot">-&gt;</span> <span class="dt">KleisliOptic</span> m s t a b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>kleisliOptic (<span class="dt">ExistentialKleisliOptic</span> g p) k s</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> act <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">&gt;&gt;=</span> (<span class="fu">uncurry</span> p)) <span class="op">$</span> distribute <span class="op">$</span> <span class="kw">do</span> (a, z) <span class="ot">&lt;-</span> g s</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                                                   <span class="fu">pure</span> (<span class="fu">fmap</span> (z, ) (k a))</span></code></pre></div>
<p>This <em>works</em>. We can encode existential optics into van Laarhoven style in this way, all of the <code>Control.Lens</code> machinery works for it and everything seems to do the right thing. But to be sure, we’d like to convert the other way so we can ideally prove that the two types are isomorphic.</p>
<p>Going the other way is quite subtle. Up until a nearly-finished draft of this post, I had a different solution – a certain functor that carried around its own exstentially-bound type – that failed the vibe check as I was writing it up, so I gave it some more testing and found out that it was broken.</p>
<p>The first bit of inspiration for me was the trick that’s needed to convert directly from a van Laarhoven lens to a linear one, ie. <code>Lens s t a b -&gt; s -&gt; (a, b -&gt; t)</code>. The trick is to define the monomial functor type <code>Monomial a b x = (a, b -&gt; x)</code>. Instantiating the lens <code>(a -&gt; f b) -&gt; (s -&gt; f t)</code> to that monomial gives it the type <code>(a -&gt; (a, b -&gt; b)) -&gt; (s -&gt; (a, b -&gt; t))</code>, at which point we can apply the obvious input <code>\a -&gt; (a, id)</code> (which is actually the identity linear lens of that type!) to get what we need.</p>
<p>The second half of the inspiration was knowing that linear lenses can be encoded existentially: we take the residual <code>z</code> to be <code>b -&gt; t</code>, so that the forwards pass <code>s -&gt; (a, z)</code> is exactly the linear lens, and the backwards pass <code>z -&gt; b -&gt; t</code> is just function application. This fact was recorded in <a href="https://www.brunogavranovic.com/posts/2022-02-10-optics-vs-lenses-operationally.html">a blog post</a> by Bruno Gavranović, which also pointed out that it’s secretly what is happening in Conal Elliott’s paper <a href="http://conal.net/papers/essence-of-ad/">The simple essence of automatic differentiation</a>.</p>
<p>In order to make this work for kleisli optics, it turns out that we need to modify the definition of the monomial functor by sticking the monad in there <em>twice</em>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Monomial</span> m a b x <span class="ot">=</span> <span class="dt">Monomial</span> {<span class="ot">runMonomial ::</span> m (a, b <span class="ot">-&gt;</span> m x)}</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span></code></pre></div>
<p>We can get the Functor instance automagically if we switch on <code>DeriveFunctor</code>. It’s easy to make this thing an instance of both <code>RightModule m</code> and <code>Distributive m</code>, and we find out that we really do need both appearances of the monad in the type to make both of them work:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">RightModule</span> m (<span class="dt">Monomial</span> m a b) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  act (<span class="dt">Monomial</span> af) <span class="ot">=</span> <span class="dt">Monomial</span> <span class="op">$</span> <span class="kw">do</span> (a, f) <span class="ot">&lt;-</span> af</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="fu">pure</span> (a, join <span class="op">.</span> f)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Distributive</span> m (<span class="dt">Monomial</span> m a b) <span class="kw">where</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  distribute maf <span class="ot">=</span> <span class="dt">Monomial</span> <span class="op">$</span> <span class="kw">do</span> <span class="dt">Monomial</span> af <span class="ot">&lt;-</span> maf</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                                 (a, f) <span class="ot">&lt;-</span> af</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                                 <span class="fu">pure</span> (a, <span class="fu">pure</span> <span class="op">.</span> f)</span></code></pre></div>
<p>Now, given a <code>KleisliOptic m s t a b</code>, we can instantiate the functor to get a function <code>(a -&gt; m (a, b -&gt; m b)) -&gt; (s -&gt; m (a, b -&gt; m t))</code>. Now we can get an existential kleisli optic with residual type <code>z = b -&gt; m t</code>, whose backwards pass is just function application:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unKleisliOptic ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">KleisliOptic</span> m s t a b <span class="ot">-&gt;</span> <span class="dt">ExistentialKleisliOptic</span> m s t a b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>unKleisliOptic l <span class="ot">=</span> <span class="dt">ExistentialKleisliOptic</span> (runMonomial <span class="op">.</span> l (\a <span class="ot">-&gt;</span> <span class="dt">Monomial</span> (<span class="fu">pure</span> (a, <span class="fu">pure</span>)))) (<span class="op">$</span>)</span></code></pre></div>
<p>I’m a little bit suspicious about this, because linear representations of kleisli optics aren’t properly understood yet. The type <code>s -&gt; m (a, b -&gt; m t)</code> appears in section 5 of <a href="https://homepages.inf.ed.ac.uk/gdp/publications/compiler-forest.pdf">The compiler forest</a> by Budiu, Galenson and Plotkin. This type <em>shouldn’t</em> work, because linear lenses work for monoidal closed categories, and kleisli categories are (infuriatingly) not monoidal closed. The obvious choice for the internal function type in a kleisli category would be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>m</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to m y</annotation></semantics></math> but the curry isomorphism should be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi><mo>→</mo><mi>m</mi><mi>z</mi><mo>≅</mo><mi>x</mi><mo>→</mo><mi>m</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>→</mo><mi>m</mi><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \times y \to m z \cong x \to m (y \to m z)</annotation></semantics></math>, which is not the case. Yet, this type seems like it should work anyway, and we seem to be secretly using that fact to build our equivalence. So this still needs looking into.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Editor’s note: I later came back to this question in <a href="../posts/2024-04-12-enriched-closed-lenses.html">this post</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
