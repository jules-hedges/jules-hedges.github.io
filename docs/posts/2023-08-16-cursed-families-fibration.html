<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - The cursed families fibration</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>The cursed families fibration</h1>
            <article>
    <section class="header">
        Posted on August 16, 2023
        
    </section>
    <section>
        <p>This post is describing a simple construction I worked out while trying to understand the <a href="https://bentnib.org/quantitative-type-theory.html">semantics of quantitative type theory</a>. It is a variant of the families fibration, a well known construction in category theory, which is sensitive to the way that sets are made out of elements, and allows fibres to overlap. Hence it is “cursed”, which is like <a href="https://ncatlab.org/nlab/show/principle+of+equivalence">evil</a> but more.</p>
<p>Let’s begin by recalling how the families fibration works. For any category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, we can build a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C)</annotation></semantics></math>. The objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C)</annotation></semantics></math> are set-indexed families in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>: that is, a pair of an index set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathcal C)</annotation></semantics></math>. A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A) \to (Y, B)</annotation></semantics></math> is a pair of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of morphisms of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal C, A (x) \to B (f (x))</annotation></semantics></math>.</p>
<p>There is a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math> which forgets everything except the index set. This functor turns out to be a fibration. The fibre over a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is exactly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝒞</mi><mi>X</mi></msup><annotation encoding="application/x-tex">\mathcal C^X</annotation></semantics></math>, ie. the functor category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">X \to \mathcal C</annotation></semantics></math> when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is seen as a discrete category.</p>
<p>Now let’s specialise to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>=</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C = \mathbf{Set}</annotation></semantics></math>, so we are considering the fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \to \mathbf{Set}</annotation></semantics></math>. A magical property of the category of sets is that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mi>X</mi></msup><mo>≅</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mi>/</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}^X \cong \mathbf{Set} / X</annotation></semantics></math>. Let’s go through how this equivalence works. In the forwards direction, we have an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathbf{Set})</annotation></semantics></math>, which we turn into its disjoint union equipped with the projection onto the index set, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\sum_{x \in X} A (x) \to X</annotation></semantics></math>. In the backwards direction, we have a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : X' \to X</annotation></semantics></math>, which we turn into an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family by inverse images: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∈</mo><msup><mi>X</mi><mo>′</mo></msup><mo>∣</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A (x) = \{ x' \in X' \mid f(x') = x \}</annotation></semantics></math>. Both of these turn out to be functorial and define an equivalence of categories.</p>
<p>Doing this on the total category gives us an equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \cong \mathbf{Set}^\to</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> is the arrow category, whose objects are functions and morphisms are commuting squares. The equivalence looks basically the same: an object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A)</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math> goes to the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\sum_{x \in X} A(x) \to X</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math>, and the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : X' \to X</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> goes to the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>f</mi><mrow><mi>−</mi><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><msub><mo stretchy="false" form="postfix">)</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, f^{-1} (x)_{x \in X})</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math>.</p>
<p>This extends to an equivalence of fibrations, where the families fibration corresponds to the codomain fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mo>:</mo><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cod} : \mathbf{Set}^\to \to \mathbf{Set}</annotation></semantics></math>.</p>
<p>Ok, that concludes our very condensed recap of the families construction. Now let’s make it <em>cursed</em>.</p>
<p>The objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> (fraktur is the appropriate font for a cursed object) are the same as the objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math>: a pair of a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>→</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathbf{Set})</annotation></semantics></math>. However, we restrict the morphisms (so we get a wide subcategory). A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A) \to (Y, B)</annotation></semantics></math> is a pair of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x, -) : A (x) \to B (f (x))</annotation></semantics></math> satsifying an additional property: that if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>∩</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \in A (x_1) \cap A (x_2)</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x_1, a) = f' (x_2, a)</annotation></semantics></math>, and consequently, both are elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>∩</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B (f (x_1)) \cap B (f (x_2))</annotation></semantics></math>. (And if this intersection is empty then no morphism of this type can exist.)</p>
<p>This is fundamentally using the fact that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math> is untyped, and we can talk about the intersection of arbitrary sets.</p>
<p>The intuition is that morphisms are not allowed to use their knowledge of the index, unless it can be deduced from the rest of their input. I’ll go through a detailed example of this later.</p>
<p>Just as there is an equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐅</mi><mi>𝐚</mi><mi>𝐦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \cong \mathbf{Set}^\to</annotation></semantics></math>, there is a cursed counterpart of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>→</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> that is equivalent to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math>. I’ll call this category$ ^$. An object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> is a pair of sets equipped with a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math>. A morphism from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>Y</mi><mo>×</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">S \subseteq Y \times Y'</annotation></semantics></math> is a pair of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>′</mo></msup><mo>:</mo><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">f' : X' \to Y'</annotation></semantics></math> such that if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">x R x'</annotation></semantics></math> then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mi>S</mi><msup><mi>f</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (x) S f' (x')</annotation></semantics></math>.</p>
<p>One perspective on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> is that it’s the category of morphisms in the double category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><annotation encoding="application/x-tex">\mathbf{Rel}</annotation></semantics></math> whose proarrows are binary relations.</p>
<p>We can turn an object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A)</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> into an object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> by taking the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∪</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cup_{x \in X} A (x)</annotation></semantics></math> together with the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><msub><mo>∪</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R \subseteq X \times \cup_{x \in X} A (x)</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">x R x'</annotation></semantics></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>′</mo></msup><mo>∈</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x' \in A (x)</annotation></semantics></math>. Conversely, a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math> we can do the relational equivalent of inverse images to get the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>x</mi><mo>′</mo></msup><mo>∈</mo><msup><mi>X</mi><mo>′</mo></msup><mo>∣</mo><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A (x) = \{ x' \in X' \mid x R x' \}</annotation></semantics></math>.</p>
<p>Both <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> are fibred over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>, the latter being by the relational version of codomain, and the equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><mo>≅</mo><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup></mrow><annotation encoding="application/x-tex">\mathfrak{Fam} \cong \mathbf{Set}^\leftrightarrow</annotation></semantics></math> extends to an equivalence of fibrations.</p>
<p>Here is a simple example, which was suggested by Zanzi. Given a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>, we have the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math> of lists, the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mi>n</mi></msup><annotation encoding="application/x-tex">X^n</annotation></semantics></math> of lists of length <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, and the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">X^{* \leq n}</annotation></semantics></math> of lists of length at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mi>n</mi></msup><annotation encoding="application/x-tex">X^n</annotation></semantics></math> are non-overlapping for distinct <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, that is to say, two lists of different lengths cannot be equal. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math> is in natural bijection with the disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow></msub><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\sum_{n \in \mathbb N} X^n</annotation></semantics></math> (whose elements are pairs of a number and a list of that length), and is equal on the nose to the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∪</mo><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow></msub><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\cup_{n \in \mathbb N} X^n</annotation></semantics></math>.</p>
<p>On the other hand, the sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">X^{* \leq n}</annotation></semantics></math> overlap: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>m</mi></mrow></msup><mo>⊆</mo><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{* \leq m} \subseteq X^{* \leq n}</annotation></semantics></math> iff <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \leq n</annotation></semantics></math>. The disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow></msub><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{n \in \mathbb N} X^{* \leq n}</annotation></semantics></math> consists of pairs of a list and an upper bound on its length. But the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∪</mo><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow></msub><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\cup_{n \in \mathbb N} X^{* \leq n}</annotation></semantics></math> is still equal on the nose to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math>.</p>
<p>Suppose we want to talk about the length function, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> considered as a baby model of quantitative type theory. Consider the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>ℕ</mi><mo>,</mo><msubsup><mi>X</mi><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb N, X^{* \leq n}_{n \in \mathbb N})</annotation></semantics></math>, which models an “irrelevant Sigma type” where an upper bound on the length is available at the type level but may not be used at the value level.</p>
<p>The set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℕ</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math> is not a dependent type, so we consider it trivially <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-indexed, by the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>ℕ</mi><mrow><mi>*</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\{ * \}, \mathbb N_{* \in \{ * \}})</annotation></semantics></math>. There is a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>ℕ</mi><mo>,</mo><msubsup><mi>X</mi><mrow><mi>n</mi><mo>∈</mo><mi>ℕ</mi></mrow><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msubsup><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>ℕ</mi><mrow><mi>*</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb N, X^{* \leq n}_{n \in \mathbb N}) \to (\{ * \}, \mathbb N_{* \in \{ * \}})</annotation></semantics></math>, given by the unique function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb N \to \{ * \}</annotation></semantics></math> together with the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℕ</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math>-indexed family of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msup><mi>X</mi><mrow><mi>*</mi><mo>≤</mo><mi>n</mi></mrow></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">f (n, -) : X^{* \leq n} \to \mathbb N</annotation></semantics></math> that ignores <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and returns the actual length of the list. This satisfies the condition to be a morphism of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔉</mi><mi>𝔞</mi><mi>𝔪</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math>.</p>
<p>We can say the same thing equivalently in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math>, where the corresponding object is the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>ℕ</mi><mo>×</mo><msup><mi>X</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq \mathbb N \times X^*</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">n R x</annotation></semantics></math> if the length of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The object corresponding to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℕ</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math> is the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>×</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">S \subseteq \{ * \} \times \mathbb N</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>*</mi><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">* S n</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The corresponding morphism is given by the unique function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℕ</mi><mo>→</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb N \to \{ * \}</annotation></semantics></math> and the length function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>*</mo></msup><mo>→</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">X^* \to \mathbb N</annotation></semantics></math>. This satisfies the condition to be a morphism of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo>↔</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math>.</p>
<p>That’s all for today, but I’ll leave a puzzle. All of this was very heavily specialised to working concretely with sets. What structure could we put on a category in order that we can talk about “intersections of objects” in this way? <a href="https://www.brunogavranovic.com/">Bruno</a> suggested that what we need is a Grothendieck (possibly pre-)topology. I find this very plausible: two objects have nonempty overlap if they admit covering families with an object in common. But I’ll definitely leave the details of this for another day.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
