<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Foundations of bidirectional programming III: The logic of lenses</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Foundations of bidirectional programming III: The logic of lenses</h1>
            <article>
    <section class="header">
        Posted on September 12, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/09/12/bidirectional-programming-iii/">X-posted on the CyberCat Institute blog</a>)</p>
<p>See parts <a href="https://cybercat.institute/2024/08/26/bidirectional-programming-i/">I</a> and <a href="https://cybercat.institute/2024/09/05/bidirectional-programming-ii/">II</a> of this series. There is also now a <a href="https://github.com/CyberCat-Institute/Aptwe">source repo</a>!</p>
<p>In this post we will make probably the single most important step from a generic type theory to one specialised to bidirecional programming.</p>
<p>In a bidirectional language there are 2 kinds of variables: ones travelling forwards in time, and ones travelling backwards in time. I will refer to the types of these variables <em>covariant</em> and <em>contravariant</em> for short (or at least shorter). Variables of covariant type are the ones we are used to: they behave according to ordinary <em>cartesian</em> scoping rules, which means they can be implicitly deleted (referred to zero times) and implicitly copied (referred to more than once).</p>
<p>Variables of <em>cocartesian</em> type are the weird ones. They can also be implicitly copied and deleted, but because they are going backwards, from the forwards perspective it looks like they can be implicitly <em>merged</em> and <em>spawned</em>. By <em>spawned</em> I mean they can be bound zero times and still referred to; and by <em>merged</em> I mean they can be bound twice without the later binding shadowing the earlier binding. On the other hand they can <em>not</em> be implicitly copied or deleted. Their scoping rules are <em>cocartesian</em>.</p>
<p>I can now reveal that my <em>party trick</em> in the last section of my <a href="https://cybercat.institute/2024/08/26/bidirectional-programming-i/">first post</a> where I built a cocartesian language was secretly not in fact a party trick after all, but was all along in preparation for this exact moment.</p>
<p>Now suppose we take a tensor product of a covariant type and a contravariant type. Now we have a variable referring to a bundle of a cartesian value, which can be deleted and copied but not spawned or merged, and a cocartesian value, which can be spawned and merged but not deleted or copied. Since doing any of these operations to a pair means doing it to both, our variable cannot be deleted or copied or spawned or merged, which means it is a <em>linear</em> variable. I will refer to such a tensor product type as <em>invariant</em>. Secretly, all of the types in my <a href="https://cybercat.institute/2024/09/05/bidirectional-programming-ii/">second post</a> were invariant, since that language was linear.</p>
<p>There is a secret fourth thing, which is variables with <em>bicartesian</em> scoping rules, so they can be deleted and copied and spawned and merged. I will refer to these types as <em>bivariant</em>. It would be entirely reasonable to not include these, but I have a secret plan for them that will be revealed in the next post. For now, the only bivariant type will be the monoidal unit.</p>
<h2 id="the-4-kinds-of-things">The 4 kinds of things</h2>
<p>Just as terms are classified by types, types are classified by <em>kinds</em>, which means I have been talking about kinds the whole time. But these are not kinds as we know them from languages like Haskell. We have the added complication that kinds control the scoping rules of variables of the types they classify; but on the other hand we have the added simplification that there are <em>exactly</em> 4 kinds, rather than an infinite supply of them. I have to thank <a href="https://www.rntz.net/index.html">Michael Arntzenius</a>, who visited Zanzi and me a few weeks ago, for planting the idea of a 4-element lattice of kinds.</p>
<p>Let’s start with the easy parts:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Kind</span> <span class="op">:</span> <span class="dt">Type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Kind</span> <span class="ot">=</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> <span class="op">:</span> <span class="dt">Kind</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Unit</span> <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, <span class="dt">True</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ground</span> <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, <span class="dt">False</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Not</span> <span class="op">:</span> <span class="dt">Ty</span> (cov, con) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (con, cov)</span></code></pre></div>
<p>I implement the 4-element lattice as the product <code>(Bool, Bool)</code>, where the first flag tracks whether the type is covariant and the second whether it is contravariant. I anticipate that much later, probably when I add type polymorphism, it will become necessary to take seriously that there are subkind relationships here, but I will cross that particular bridge when it is in front of me. <code>Unit</code> is a bivariant type, <code>Ground</code> is a covariant type (it is still a placeholder, and in the next post will be replaced with a proper system for base types). The <code>Not</code> operator acts on the underlying kind by interchanging the covariant and contravariant capabilities; so strictly covariant types become strictly contravariant and vice versa, whereas the bivariant and invariant kinds are both stable under negation.</p>
<p>There is an alternative way of implementing it, but it is much more tedious: instead of representing kinds explicitly, have 4 different versions of <code>Ty</code> for each of the 4 kinds. That leads to a proliferation of type operators - 4 operators for <code>Not</code> and 16 for <code>Tensor</code> (which we’re coming to next), 1 for each combination of kinds of the 2 inputs. I really hope that won’t be necessary, but it’s something I’m keeping in my back pocket just in case I run into an insurmountable problem with this encoding.</p>
<p>Now we come to the hard part: tensor products. A tensor product is covariant if both parts are covariant, and is contravariant if both parts are contravariant. In a world with a sufficiently smart typechecker we would simply write this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tensor</span> <span class="op">:</span> <span class="dt">Ty</span> (covx, conx) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (covy, cony)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Ty</span> (covx <span class="op">&amp;&amp;</span> covy, conx <span class="op">&amp;&amp;</span> cony)</span></code></pre></div>
<p>But we already know how to handle this situation, it’s the same idea as for list concatenation in the <a href="https://cybercat.institute/2024/08/26/bidirectional-programming-i/">first post</a>. We define the relation corresponding to the boolean conjunction function, and a section of it:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">And</span> <span class="op">:</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span>  <span class="op">:</span> <span class="dt">And</span> <span class="dt">True</span> b b</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span> <span class="op">:</span> <span class="dt">And</span> <span class="dt">False</span> b <span class="dt">False</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">&amp;&amp;</span>) <span class="op">:</span> (a <span class="op">:</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (b <span class="op">:</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (c <span class="op">:</span> <span class="dt">Bool</span> <span class="op">**</span> <span class="dt">And</span> a b c)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span>  <span class="op">&amp;&amp;</span> b <span class="ot">=</span> (b <span class="op">**</span> <span class="dt">True</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="op">&amp;&amp;</span> b <span class="ot">=</span> (<span class="dt">False</span> <span class="op">**</span> <span class="dt">False</span>)</span></code></pre></div>
<p>(Here’s I’m having fun with Idris’ ability to disambiguate names based on typing information, something I really wish I could do in Haskell.)</p>
<p>Now we can write the actual definition of tensor products, which is much more complicated looking than it should be, but this is just what we have to deal with until the day when somebody builds a typechecker that can handle trivial equational reasoning:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tensor</span> <span class="op">:</span> {covx, covy, conx, cony <span class="op">:</span> <span class="dt">Bool</span>}</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> {default (covx <span class="op">&amp;&amp;</span> covy) cov <span class="op">:</span> _} <span class="ot">-&gt;</span> {default (conx <span class="op">&amp;&amp;</span> cony) con <span class="op">:</span> _}</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Ty</span> (covx, conx) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (covy, cony) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (cov<span class="op">.</span><span class="fu">fst</span>, con<span class="op">.</span><span class="fu">fst</span>)</span></code></pre></div>
<h2 id="the-scoping-rules">The scoping rules</h2>
<p>Now we come to the main topic of this post: how kinds influence scoping rules. In the <a href="https://cybercat.institute/2024/08/26/bidirectional-programming-i/">first post</a> we saw how to implement context morphisms for planar, linear, cartesian and cocartesian languages. Those definitions were all polymorphic over arbitrary lists. Then in the <a href="https://cybercat.institute/2024/09/05/bidirectional-programming-ii/">second post</a> we defined context morphisms that could introduce and elimination double negations, which was no longer polymorphic but specialised to a particular language of types, and this will continue.</p>
<p>Now that types are indexed by kinds, everything else becomes more complicated: everything we do from now on becomes additionally indexed by kinds, starting with this.</p>
<p>(Note, I decided to reuse the name <code>Structure</code>, since this should be the last one we ever need.)</p>
<p>Let’s start with the linear rules:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Structure</span> <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span>  <span class="op">:</span> <span class="dt">Structure</span> [] []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Insert</span> <span class="op">:</span> {a, b <span class="op">:</span> <span class="dt">Ty</span> (cov, con)} <span class="ot">-&gt;</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs}</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Parity</span> a b <span class="ot">-&gt;</span> <span class="dt">IxInsertion</span> a as as' <span class="ot">-&gt;</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> as' (<span class="ot">b ::</span> bs)</span></code></pre></div>
<p>Here <code>IxInsertion</code> is an indexed version of the <code>Insertion</code> datatype from the previous post, relationally defining insertions into an <code>All</code> type indexed by an underlying list:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IxInsertion</span> <span class="op">:</span> {<span class="dv">0</span> x <span class="op">:</span> a} <span class="ot">-&gt;</span> p x </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> {<span class="dv">0</span> xs <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> <span class="dt">All</span> p xs </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> {<span class="dv">0</span> ys <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> <span class="dt">All</span> p ys <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span> <span class="op">:</span> <span class="dt">IxInsertion</span> {x} a {xs} as {ys <span class="ot">= x ::</span> xs} (<span class="ot">a ::</span> as)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span> <span class="op">:</span> <span class="dt">IxInsertion</span> {x} a {xs} as {ys} bs </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="dt">IxInsertion</span> {x <span class="ot">=</span> x} a {xs <span class="ot">= y ::</span> xs} (<span class="ot">b ::</span> as) {ys <span class="ot">= y ::</span> ys} (<span class="ot">b ::</span> bs)</span></code></pre></div>
<p>I’m not going to explain all of the syntax and semantics of Idris happening here because it would take us too far afield, and despite appearances this is not intended to be a tutorial series on Idris programming. Suffice to say, defining indexed versions of standard datatypes is <em>significantly</em> harder than defining the originals.</p>
<p>The definition of <code>Parity</code>, which handles double negations, is unchanged from the previous post besides adding the kind indexes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Parity</span> <span class="op">:</span> <span class="dt">Ty</span> (cov, con) <span class="ot">-&gt;</span> <span class="dt">Ty</span> (cov, con) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span>    <span class="op">:</span> <span class="dt">Parity</span> a a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Raise</span> <span class="op">:</span> <span class="dt">Parity</span> a b <span class="ot">-&gt;</span> <span class="dt">Parity</span> a (<span class="dt">Not</span> (<span class="dt">Not</span> b))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lower</span> <span class="op">:</span> <span class="dt">Parity</span> a b <span class="ot">-&gt;</span> <span class="dt">Parity</span> (<span class="dt">Not</span> (<span class="dt">Not</span> a)) b</span></code></pre></div>
<p>The Idris typechecker is, at least, smart enough to figure out that double negation leaves the kind unchanged. This is one reason that I write out kinds as pairs of booleans everywhere rather than defining a function <code>swap : Kind -&gt; Kind</code>, since that causes Idris to get stuck here.</p>
<p>One thing to note is that I reversed the polarity of the <code>Insert</code> constructor from the previous post, so that it now conses on the codomain and inserts on the domain rather than the other way round. The previous post was “supply driven”, saying where everything in the domain goes in the codomain, whereas this version is “demand driven”, saying where everything in the codomain came from in the domain. This was a late change after I experienced manually defining terms in this core syntax and found that this way makes manual proof search much easier. If it later turns out that the original supply driven version makes writing elaborators easier, it’s an easy change to turn it back.</p>
<p>Next we have the rules for delete and copy, which can be applied only to covariant types. We don’t care whether the type is also contravariant, ie. we can use it for both strictly covariant types and bivariant types. This is the other reason I define kinds to be pairs of booleans rather than their own dedicated language, because otherwise we would have twice as many constructors here.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Delete</span> <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, con)} <span class="ot">-&gt;</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> (<span class="ot">a ::</span> as) bs</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Copy</span>   <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, con)} <span class="ot">-&gt;</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> xs} </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IxElem</span> a as <span class="ot">-&gt;</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> as (<span class="ot">a ::</span> bs)</span></code></pre></div>
<p>Here <code>IxElem</code> is, of course, an indexed version of the <code>Elem</code> datatype, which I won’t bother to write here but was also painful to define. (If you want to you can find it in the <a href="https://github.com/CyberCat-Institute/Aptwe/blob/main/src/IxUtils.idr">IxUtils</a> module of the source repo.)</p>
<p>With that, defining the constructors for spawn and merge is easy, and completes our definition of <code>Structure</code> once and for all.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Spawn</span>  <span class="op">:</span> {b <span class="op">:</span> <span class="dt">Ty</span> (cov, <span class="dt">True</span>)} <span class="ot">-&gt;</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> as (<span class="ot">b ::</span> bs)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Merge</span>  <span class="op">:</span> {b <span class="op">:</span> <span class="dt">Ty</span> (cov, <span class="dt">True</span>)} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> ys} </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IxElem</span> b bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Structure</span> (<span class="ot">b ::</span> as) bs</span></code></pre></div>
<h2 id="the-full-logic-of-lenses">The full logic of lenses</h2>
<p>We can now put the pieces together and make the first real definition of our kernel language. I hope that nothing here will change, only be added to in the future.</p>
<p>Of course everything is kind indexed:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> ks <span class="ot">-&gt;</span> <span class="dt">Ty</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="op">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Rename</span> <span class="op">:</span> <span class="dt">Structure</span> as bs <span class="ot">-&gt;</span> <span class="dt">Term</span> bs x <span class="ot">-&gt;</span> <span class="dt">Term</span> as x</span></code></pre></div>
<p>I renamed <code>Act</code> to <code>Rename</code> since the last post, since somebody pointed out that’s what it is.</p>
<p>Unit introduction and elimination rules work as they did before:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitIntro</span> <span class="op">:</span> <span class="dt">Term</span> [] <span class="dt">Unit</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">UnitElim</span> <span class="op">:</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs} <span class="ot">-&gt;</span> {default (ixSimplex as bs) cs <span class="op">:</span> _}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> as <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> bs x <span class="ot">-&gt;</span> <span class="dt">Term</span> (cs<span class="op">.</span><span class="fu">snd</span><span class="op">.</span><span class="fu">fst</span>) x</span></code></pre></div>
<p>Here <code>ixSimplex</code> is the tactic corresponding to a datatype <code>IxSimplex</code> which is the relational version of the indexed version of <code>++</code>, operating on <code>All</code> rather than <code>List</code>. This one is worth writing down because it returns a twice-iterated Sigma type, so we have to extract the part we need with <code>.snd.fst</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IxSimplex</span> <span class="op">:</span> {<span class="dv">0</span> xs <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> <span class="dt">All</span> p xs </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> {<span class="dv">0</span> ys <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> <span class="dt">All</span> p ys </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> {<span class="dv">0</span> zs <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> <span class="dt">All</span> p zs <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span> <span class="op">:</span> <span class="dt">IxSimplex</span> [] bs bs</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span> <span class="op">:</span> <span class="dt">IxSimplex</span> {xs} as {ys} bs {zs} cs </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="dt">IxSimplex</span> {xs <span class="ot">= x ::</span> xs} (<span class="ot">a ::</span> as) {ys <span class="ot">=</span> ys} bs {zs <span class="ot">= x ::</span> zs} (<span class="ot">a ::</span> cs)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>ixSimplex <span class="op">:</span> {xs <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> (as <span class="op">:</span> <span class="dt">All</span> p xs)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> {ys <span class="op">:</span> <span class="dt">List</span> a} <span class="ot">-&gt;</span> (bs <span class="op">:</span> <span class="dt">All</span> p ys)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> (zs <span class="op">:</span> <span class="dt">List</span> a <span class="op">**</span> cs <span class="op">:</span> <span class="dt">All</span> p zs <span class="op">**</span> <span class="dt">IxSimplex</span> as bs cs)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>ixSimplex {xs <span class="ot">=</span> []} [] {ys} bs <span class="ot">=</span> (ys <span class="op">**</span> bs <span class="op">**</span> <span class="dt">Z</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>ixSimplex {xs <span class="ot">= x ::</span> xs} (<span class="ot">a ::</span> as) {ys} bs </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="kw">let</span> (zs <span class="op">**</span> cs <span class="op">**</span> n) <span class="ot">=</span> ixSimplex {xs <span class="ot">=</span> xs} as {ys <span class="ot">=</span> ys} bs </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (<span class="ot">x ::</span> zs <span class="op">**</span><span class="ot"> a ::</span> cs <span class="op">**</span> <span class="dt">S</span> n)</span></code></pre></div>
<p>Now we come to the negation rules, and the final twist of this post. In the language we reached at the end of the <a href="https://cybercat.institute/2024/09/05/bidirectional-programming-ii/">previous post</a>, which amounts to the fragment of this language for only invariant types, there was no not-introduction rule - correctly so. As I speculated there, there are indeed some valid instances of not-introduction, but they are not sufficient to prove general double negation introduction or elimination - and they can’t even be expressed without the kind system we developed in this post.</p>
<p>It turns out that we have two not-introduction rules, one that is valid for covariant types and one that is valid for contravariant types. This introduces a sort of incompatibility between negation and tensor, since the tensor product of two variables with a valid not-introduction rule can fail to have one.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotIntroCov</span> <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span> (<span class="dt">True</span>, con)} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">a ::</span> as) <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> as (<span class="dt">Not</span> a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotIntroCon</span> <span class="op">:</span> {a <span class="op">:</span> <span class="dt">Ty</span> (cov, <span class="dt">True</span>)} <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">a ::</span> as) <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> as (<span class="dt">Not</span> a)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotElim</span> <span class="op">:</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs} <span class="ot">-&gt;</span> {default (ixSimplex as bs) cs <span class="op">:</span> _}</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Term</span> as (<span class="dt">Not</span> x) <span class="ot">-&gt;</span> <span class="dt">Term</span> bs x <span class="ot">-&gt;</span> <span class="dt">Term</span> (cs<span class="op">.</span><span class="fu">snd</span><span class="op">.</span><span class="fu">fst</span>) <span class="dt">Unit</span></span></code></pre></div>
<p>I would say that this is the first case where my well typed by construction methodology enabled me to do something that I think I would have failed at otherwise. I figured out these rules at the same time as the corresponding cases of the well typed evaluator (which will be the topic of the next post). Although they look like they are among the simplest rules in the language, they are the ones I understand by far the least.</p>
<p>If we have a bivariant type then both of these rules can be applied to produce the same result. It seems tempting to try to roll these two rules into one, which can be applied when <em>either</em> <code>cov</code> or <code>con</code> is <code>True</code>. This is a bit tricky to do, but it turns out to also be a bad idea: although these rules are <em>logically</em> equivalent, they are not <em>type-theoretically</em> equivalent: they have completely different operational semantics! And by that I don’t mean something like different evaluation strategies, I mean that they actually output different results.</p>
<p>Now there’s only the tensor rules, and for once there is nothing to say about them, they are the indexed versions of the tensor rules from the last 2 posts.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="op">:</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs} <span class="ot">-&gt;</span> {default (ixSimplex as bs) cs <span class="op">:</span> _}</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> as x <span class="ot">-&gt;</span> <span class="dt">Term</span> bs y <span class="ot">-&gt;</span> <span class="dt">Term</span> (cs<span class="op">.</span><span class="fu">snd</span><span class="op">.</span><span class="fu">fst</span>) (<span class="dt">Tensor</span> x y)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="op">:</span> {as <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kas} <span class="ot">-&gt;</span> {bs <span class="op">:</span> <span class="dt">All</span> <span class="dt">Ty</span> kbs} <span class="ot">-&gt;</span> {default (ixSimplex as bs) cs <span class="op">:</span> _}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> as (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (<span class="ot">x :: y ::</span> bs) z <span class="ot">-&gt;</span> <span class="dt">Term</span> (cs<span class="op">.</span><span class="fu">snd</span><span class="op">.</span><span class="fu">fst</span>) z</span></code></pre></div>
<p>And that’s it!</p>
<p>Like I said, in the next post we will build a well typed evaluator, which means we will also write and run our first programs - and we can already do some interesting things, like basic automatic differentiation. The only small thing that will need to be added to the language from this post is a mechanism for adding basic types and basic terms, such as arithmetic operators between doubles.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
