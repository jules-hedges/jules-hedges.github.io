<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Autodiff through function types: Categorical semantics the ultimate backpropagator</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/fonts.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="me" href="https://mathstodon.xyz/@julesh" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Autodiff through function types: Categorical semantics the ultimate backpropagator</h1>
            <article>
    <section class="header">
        Posted on February 20, 2026
        
    </section>
    <section>
        <p>In this post we will see how to extend reverse mode automatic differentiation to a language with first class function types, function application and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction. This method is not new, but we will give a new derivation of it by showing how it arises universally from noticing that the category of ‚Äúadditive lenses‚Äù is cartesian closed. In the end we will see that this idea sounds like it should revolutionise machine learning, but then doesn‚Äôt. Everything in this post is joint work with <a href="https://www.brunogavranovic.com/">Bruno Gavranoviƒá</a>, who is now my colleague at <a href="https://glaive-research.org/">Glaive</a>.</p>
<h2 id="additive-containers-and-additive-lenses">Additive containers and additive lenses</h2>
<p>We need to begin with some background categorical cybernetics, from the paper <a href="https://arxiv.org/abs/2103.01931">Categorical foundations of gradient-based learning</a> and <a href="https://arxiv.org/abs/2403.13001">Bruno‚Äôs PhD thesis</a>.</p>
<p>The categorical semantics of types in a differentiable language are <em>additive containers</em>, which is what we call <em>set-indexed families of commutative monoids</em>. (The reason we use an unnecessarily fancy word is because set-indexing is stronger than we sometimes want or need; categorical cybernetics has lots of machinery for working with related objects so we use terminology that unifies them.) The idea is the semantics of a type is (1) a set of values that the type can have in the forwards pass, and (2) for each of those values, a commutative monoid of derivatives it can have at that value in the backwards pass.</p>
<p>The semantics of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math> is an <em>additive lens</em> between the additive containers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A')</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(B, B')</annotation></semantics></math>. This consists of two things: (1) an ordinary function between sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math> describing the semantics of the forwards pass, and (2) an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>-indexed family of monoid homomorphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>‚àí</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x, -)</annotation></semantics></math> from the commutative monoid <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B' (f (x))</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A' (x)</annotation></semantics></math>. That is to say, these are dependent lenses whose backwards passes are additive in their second input. The chain rule for lens composition exactly describes the denotational semantics of how the forwards and backwards passes interact in autodiff.</p>
<p>In the category of <em>ordinary</em> containers and lenses, without the monoid structure, we have both a <em>cartesian product</em> and a <em>tensor product</em>. The cartesian product of containers (ie. it satisfies the universal property) is given by product in the forwards pass and <em>coproduct</em> in the backwards pass: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo>+</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \times (B, B') = (A \times B, A' + B')</annotation></semantics></math>. (To be more specific, the backwards part is the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A \times B)</annotation></semantics></math>-indexed family of sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo>+</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A' + B') (x, y) = A' (x) + B' (y)</annotation></semantics></math>.) This happens essentially because the backwards pass is backwards, so the universal property of a product turns into a coproduct. There is <em>also</em> a tensor product given by product in the forwards and backwards passes: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚äó</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo>√ó</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \otimes (B, B') = (A \times B, A' \times B')</annotation></semantics></math>. For the majority of applications in categorical cybernetics the tensor product is the useful one, but it doesn‚Äôt satisfy a straightforward universal property.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>But in additive containers something different happens: the thing that satisfies the universal property of a cartesian product switches to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo>√ó</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \times (B, B') = (A \times B, A' \times B')</annotation></semantics></math>. The structural reason for this is that the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÇ</mi><mi>ùêå</mi><mi>ùê®</mi><mi>ùêß</mi></mrow><annotation encoding="application/x-tex">\mathbf{CMon}</annotation></semantics></math> of commutative monoids has finite <em>biproducts</em>: the monoid of pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>√ó</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \times B</annotation></semantics></math> satisfies the universal properties of both a product and a coproduct. It‚Äôs worth thinking for a moment about why this is: given maps <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f : A \to C</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g : B \to C</annotation></semantics></math>, we get a copairing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">]</mo><mo>:</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">[f, g] : A \times B \to C</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[f, g] (x, y) = f (x) + g (y)</annotation></semantics></math>; and injections are given by setting one of the values to be zero.</p>
<p>This gives the correct semantics to copying in autodiff: if we use a forwards pass value multiple times, we get a different derivative coming from each use site and the right thing to do is to <em>add</em> those derivatives.</p>
<h2 id="additive-containers-are-cartesian-closed">Additive containers are cartesian closed</h2>
<p>The category of ordinary containers and ordinary lenses is <em>monoidal</em> closed for the tensor product.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Given containers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A')</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(B, B')</annotation></semantics></math>, the hom-container has as its forwards set the set of all lenses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \to (B, B')</annotation></semantics></math>, and as the backwards set indexed by a specific lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, f') : (A, A') \to (B, B')</annotation></semantics></math> it has the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma (x : A) . B' (f (x))</annotation></semantics></math>, whose elements are pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msup><mi>y</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y')</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo>‚Ä≤</mo></msup><mo>:</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y' : B' (f (x))</annotation></semantics></math>. Writing this whole container as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \multimap (B, B')</annotation></semantics></math>, this gives us the universal property that lenses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚äó</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>C</mi><mo>,</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \otimes (B, B') \to (C, C')</annotation></semantics></math> are in natural bijection with lenses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>C</mi><mo>,</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \to (B, B') \multimap (C, C')</annotation></semantics></math>.</p>
<p>Meanwhile in the world of additive containers, the thing that was previously just the tensor product is now the cartesian product, so we might wonder whether additive containers are <em>cartesian</em> closed. And they are! The forwards set of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \multimap (B, B')</annotation></semantics></math> is, as expected, the set of additive lenses of that type. (I am going to continue using the symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚ä∏</mo><annotation encoding="application/x-tex">\multimap</annotation></semantics></math> for the internal hom of additive containers, to carefully distinguish it from functions in the underlying category of sets.) But there is a very interesting twist in the backwards part.</p>
<p>The backwards monoid is still the thing that we would write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma (x : A) . B' (f (x))</annotation></semantics></math>. It is the coproduct in the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÇ</mi><mi>ùêå</mi><mi>ùê®</mi><mi>ùêß</mi></mrow><annotation encoding="application/x-tex">\mathbf{CMon}</annotation></semantics></math> of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>-indexed family of monoids <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B' (f (x))</annotation></semantics></math>. So we need to know what coproducts of commutative monoids are like. The category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÇ</mi><mi>ùêå</mi><mi>ùê®</mi><mi>ùêß</mi></mrow><annotation encoding="application/x-tex">\mathbf{CMon}</annotation></semantics></math> has finite biproducts, but for infinite families products and coproducts no longer coincide. The product remains the obvious thing, the monoid whose elements are dependent functions - this is called a <em>direct product</em>. The coproduct is a slightly different construction called a <em>direct sum</em>: an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma (x : A) . B' (f (x))</annotation></semantics></math> is a dependent function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x : A) \to B' (f (x))</annotation></semantics></math> satisfying the property that all except finitely many values are zero. That is, it is a <em>finite support dependent function</em>. (The monoid structure is pointwise addition of functions.) The underlying set of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma (x : A) . B' (f (x))</annotation></semantics></math> is something I would write as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Œ†</mi><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Pi_{\mathrm{fs}} (x : A) . B' (f (x))</annotation></semantics></math>.</p>
<p>It‚Äôs worth also spending a moment thinking about why the coproduct has to be something like this. Suppose we have an infinite family of monoids <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>i</mi></msub><annotation encoding="application/x-tex">A_i</annotation></semantics></math>, and for each of them we have a map out <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>:</mo><msub><mi>A</mi><mi>i</mi></msub><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f_i : A_i \to B</annotation></semantics></math>. We need to be able to take their ‚Äúcotupling‚Äù <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msub><mi>f</mi><mi>i</mi></msub><msub><mo stretchy="false" form="postfix">]</mo><mi>i</mi></msub><mo>:</mo><msub><mi mathvariant="normal">Œ£</mi><mi>i</mi></msub><msub><mi>A</mi><mi>i</mi></msub><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">[f_i]_i : \Sigma_i A_i \to B</annotation></semantics></math>, which we know from the binary case should be to evaluate each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_i (a_i)</annotation></semantics></math> and then add the results in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>. But <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> doesn‚Äôt admit any kind of infinitary addition in general, so we can only do this if we know that only finitely many of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math> are nonzero.</p>
<p>To summarise: the category of additive containers and additive lenses is cartesian closed, where the hom-container <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, A') \multimap (B, B')</annotation></semantics></math> has as its forwards set the set of additive lenses, and where the backwards commutative monoid over an additive lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, f')</annotation></semantics></math> is the coproduct of commutative monoids <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Sigma (x : A) . B' (f (x))</annotation></semantics></math>, whose underlying set is the set of finite support functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x : A) \to B' (f (x))</annotation></semantics></math>.</p>
<h2 id="representing-the-direct-sum">Representing the direct sum</h2>
<p>How do we represent the set of finite support functions in an implementation? The simplest idea would be to just use a function with an informal datatype invariant. But it turns out that we need the copairing operation to be implementable, which is not possible using this representation. The thing we are actually going to use is a finite list of pairs of inputs and outputs: we represent the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Œ†</mi><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Pi_{\mathrm{fs}} (x : A) . B' (f (x))</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Œ£</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">(\Sigma (x : A) . B' (f (x)))^*</annotation></semantics></math>.</p>
<p>Of course lists of pairs are not actually the same as finite support functions. For one thing the order doesn‚Äôt matter, so we need to quotient out list permutation. Our next thought might be that we should have a datatype invariant that each input value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> can only appear once in the list, so it is never ambiguous what the output should be. But there turns out to be a better way: we say that the value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (x)</annotation></semantics></math> is the <em>sum</em> of all of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math> appears in the list. (And if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> never appears then the sum is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f (x) = 0</annotation></semantics></math>.) This amounts to defining a quotient type generated by 3 classes of identifications:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>x</mi><mi>s</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>x</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(x_1, y_1), (x_2, y_2), xs = (x_2, y_2), (x_1, y_1), xs</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>x</mi><mi>s</mi><mo>=</mo><mi>x</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(x, 0), xs = xs</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>x</mi><mi>s</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>x</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">(x, y_1), (x, y_2), xs = (x, y_1 + y_2), xs</annotation></semantics></math></li>
</ul>
<p>If we happened to be working in a language with higher inductive types we could tell the machine this, but as it transpires that would be overkill: it turns out that the <em>only</em> operation we will ever need to define out of a direct sum is to add together all of its entries, and that plainly respects all of these equations. (In the case of the first one, that‚Äôs exactly where we use the fact that all of our monoids are commutative.)</p>
<p>I wrote earlier than the commutative monoid structure on finite support functions is pointwise, implicitly relying on the fact that pointwise addition of finite support functions is finite support, and the unit of pointwise addition is the constant zero function which is also finite support. The reason that we want a representation where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (x)</annotation></semantics></math> is the sum of all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math> in the list, rather than the arguably more obvious approach of requiring that each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> appears in the list at most once, is that it allows us to do a very slick magic trick: pointwise addition of functions is represented by <em>list concatenation</em>. Normally list concatenation gives results in noncommutative monoids, but it <em>is</em> commutative modulo our first quotient equation. This is a slight subtlety: our data representation uses monoids that are technically not commutative, but everything is ‚Äúheredetarily commutative‚Äù in the appropriate sense that whenever we evaluate down to actual numbers everything will work out. There is a sense in which all of our additions are ‚Äúsuspended‚Äù, and we will see later that they are ‚Äúresumed‚Äù when the backwards pass gets to the point where we created the function, namely <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction.</p>
<p>The 3 steps from function types to direct sums to lists of pairs is a combination of ideas that I have not seen together in one place. But every 2 out of 3 appear somewhere, and the connection between all 3 is no doubt folklore known to some, although we haven‚Äôt been able to find actual evidence of that. So this post <em>might</em> be the first <em>universal</em> derivation of the list-of-pairs method, in the sense that everything follows from structural principles and essentially no choices are made.</p>
<p>The connection between function types and lists of pairs seems to be credited to the paper <a href="https://engineering.purdue.edu/~qobi/papers/toplas2008.pdf">Lambda the ultimate backpropagator</a>, but I find that paper quite impenetrable, so I don‚Äôt know exactly how much of it appears there. It also appears clearly for example in <a href="https://openreview.net/forum?id=ryxuz9SzDB">The differentiable curry</a>. By far the closest I have seen is the paper <a href="https://arxiv.org/abs/2110.00446">CHAD for expressive total languages</a>, which derives cartesian closure for additive lenses appears up to the infinitary direct sum. (Literally the same category: they refer to the category of additive lenses by its less catchy standard name, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ùêÖ</mi><mi>ùêö</mi><mi>ùê¶</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mrow><mi>ùêÇ</mi><mi>ùêå</mi><mi>ùê®</mi><mi>ùêß</mi></mrow><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{CMon}^\mathrm{op})</annotation></semantics></math>.) But then they never take the final step to lists of pairs, or more importantly recognise that they may have rederived a known method but with a universal derivation. However, the paper has <a href="https://github.com/VMatthijs/CHAD">accompanying Haskell code</a> and the list of pairs construction <a href="https://github.com/VMatthijs/CHAD/blob/main/src/Types.hs#L77">does appear there</a> if you dig deeply enough.</p>
<h2 id="abstraction-and-application">Abstraction and application</h2>
<p>Let‚Äôs go through the semantics of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction and function application, which introduce and eliminate function types respectively. To do this for real we need the <em>multi</em>categorical version which tracks how a term in a programming language is a function of all of the variables it refers to; but to keep things simple let‚Äôs just do the version for categories, which is essentially the same.</p>
<p>Function application is an additive lens of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>‚ä∏</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{ap} : (A \multimap B) \times A \to B</annotation></semantics></math>. Its forwards pass takes an additive lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, f') : (A, A') \to (B, B')</annotation></semantics></math> and a value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math> to the value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f (a) : B</annotation></semantics></math>. Its backwards pass
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap} : ((f, f') : (A, A') \to (B, B')) \times (a : A) \times B' (f (a)) \to ((A, A') \multimap (B, B'))' (f, f') \times A' (a) </annotation></semantics></math>
takes an additive lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">(f, f') : A \to B</annotation></semantics></math>, a value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math> and a gradient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>‚Ä≤</mo></msup><mo>:</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">b' : B' (f (a))</annotation></semantics></math>, and we must produce a gradient in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A' (a)</annotation></semantics></math> and a function gradient in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚ä∏</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((A, A') \multimap (B, B'))' (f, f')</annotation></semantics></math>. Of course the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A' (a)</annotation></semantics></math> gradient is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><msup><mi>b</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (a, b')</annotation></semantics></math>.</p>
<p>The interesting part is the function type gradient, which is a list of pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">(a : A, B' (f (a)))^*</annotation></semantics></math>. The thing of that type that we can make is the singleton list <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><msup><mi>b</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b')</annotation></semantics></math>. That list represents the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a : A) \to B' (f (a))</annotation></semantics></math> that takes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mo>‚Ä≤</mo></msup><annotation encoding="application/x-tex">b'</annotation></semantics></math> and every other value to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>. This might sound useless, but usually the reason we would have a function is because we want to call it many times, and if we do that then the semantics of copying the function value will, in the backwards pass, concatenate all of these singletons together. This will end up tracking the total gradient from every call to each possible input of the function; since a function can only be called finitely many times in any particular run of a program this will always be a finite amount of data.</p>
<p>That covers function application. Function types are <em>made</em> using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction, an operation that takes an additive lens of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f = A \times B \to C</annotation></semantics></math> (where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> are additive containers), and turns it into an additive lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>A</mi><mo>‚Üí</mo><mi>B</mi><mo>‚ä∏</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\lambda (f) : A \to B \multimap C</annotation></semantics></math>, as through we are abstracting a variable of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. So the data we have to work with is a fowards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>√ó</mo><mi>B</mi><mo>‚Üí</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f : A \times B \to C</annotation></semantics></math> and a backwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>:</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo>‚Üí</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' : (a : A) \times (b : B) \times C' \to A' (a) \times B' (b)</annotation></semantics></math>, which we will split into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mn>1</mn></msub><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><mi>B</mi><mo>√ó</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo>‚Üí</mo><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f'_1 : (a : A) \times B \times C' \to A' (a)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mn>2</mn></msub><mo>:</mo><mi>A</mi><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>:</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo>√ó</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo>‚Üí</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f'_2 : A \times (b : B) \times C' \to B' (b)</annotation></semantics></math>.</p>
<p>The forwards pass of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda (f)</annotation></semantics></math> inputs a value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math> and must output an additive lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo>,</mo><msup><mi>B</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mo stretchy="false" form="prefix">(</mo><mi>C</mi><mo>,</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda (f) (a) : (B, B') \to (C, C')</annotation></semantics></math>. The forwards pass of that is obviously given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda (f) (a) (b) = f (a, b)</annotation></semantics></math>, and its backwards pass is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><msup><mi>c</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><msup><mi>c</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\lambda (f) (a))' (b, c') = f'_2 (a, b, c')</annotation></semantics></math>. (The fact that our forwards pass has a backwards pass is, of course, because we‚Äôre doing something higher-order.)</p>
<p>The backwards pass of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œª</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda (f)</annotation></semantics></math> takes an input <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math> and a list of pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>:</mo><mi>B</mi><mo>,</mo><msup><mi>C</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">(b : B, C' (f (a, b)))^*</annotation></semantics></math>, and it must produce a gradient in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A' (a)</annotation></semantics></math>. What we need to do is to take all of the values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><msup><mi>c</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f'_1 (a, b, c')</annotation></semantics></math>, which all live in the commuative monoid <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A' (a)</annotation></semantics></math>, and add them together. This is an example of cotupling for a direct sum.</p>
<p>In ordinary first-order autodiff, copying values leads to adding gradients. There is a sense that function types cause reverse copying to be <em>suspended</em>, carrying around a list of all gradients instead of adding them. And then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œª</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction is where the suspended operation is <em>resumed</em> and the values are actually added.</p>
<h2 id="there-is-no-free-lunch">There is no free lunch</h2>
<p>Several years ago, I was talking with Mario Alvarez-Picallo about the question of differentiating function types, and he told me a piece of wisdom. He explained that if differentiating function types worked the best possible way, then for any supervised learning problem to learn a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math>, we could choose our parameter space to be the hom-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>‚ä∏</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \multimap B</annotation></semantics></math> and our architecture to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo>:</mo><mi>A</mi><mo>√ó</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>‚ä∏</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\mathrm{ap} : A \times (A \multimap B) \to B</annotation></semantics></math>. That is, the application lens is a <em>universal architecture</em> and the hom-type is a <em>universal parameter space</em>, and in this way the entire science and art of designing deep learning architectures would be entirely obsolete. This would not be so much a free lunch as winning free lunches every day for the rest of our life. But of course, this is not what happens.</p>
<p>The catch is that we have only talked about <em>backprop</em> but not about <em>gradient descent</em>. A deep learning architecture consists of a lens of the shape <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>√ó</mo><mi>P</mi><mo>‚Üí</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \times P \to B</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> is the parameter space. A simplified view of training (ignoring batching and various other complications) works like this: we take an example pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math> from our dataset, and the current parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>. We have a loss function that takes the predicted output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (a, p)</annotation></semantics></math> and the target output <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> and gives us a gradient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mo>‚Ä≤</mo></msup><annotation encoding="application/x-tex">b'</annotation></semantics></math>, which we then inject into the backwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>p</mi><mo>,</mo><msup><mi>b</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (a, p, b')</annotation></semantics></math> which gives us an input gradient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mo>‚Ä≤</mo></msup><annotation encoding="application/x-tex">a'</annotation></semantics></math> and a parameter gradient <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>‚Ä≤</mo></msup><annotation encoding="application/x-tex">p'</annotation></semantics></math>. The input gradient is thrown away (its work is done by the time it reaches us), but the parameter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>‚Ä≤</mo></msup><annotation encoding="application/x-tex">p'</annotation></semantics></math> is sent to the <em>optimiser</em>. The most straightforward optimiser is gradient descent: it mutates the current parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>‚àí</mo><mi>Œµ</mi><msup><mi>p</mi><mo>‚Ä≤</mo></msup></mrow><annotation encoding="application/x-tex">p - \varepsilon p'</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Œµ</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math> is a <em>learning rate</em>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>This makes sense when our parameter space is some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbb R^n</annotation></semantics></math>, whose tangent space is also <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbb R^n</annotation></semantics></math>, so it forms the additive container <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>‚Ñù</mi><mi>n</mi></msup><mo>,</mo><msup><mi>‚Ñù</mi><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb R^n, \mathbb R^n)</annotation></semantics></math>. (Technically, the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbb R^n</annotation></semantics></math> is the set of points, and the second <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbb R^n</annotation></semantics></math> is the constant function that takes every point in the set to the commutative monoid of vectors with addition.) What if our parameter space is instead a space of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>‚Ñù</mi><mi>m</mi></msup><mo>‚Üí</mo><msup><mi>‚Ñù</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb R^m \to \mathbb R^n</annotation></semantics></math>, whose tangent space is the set of finite support functions from points in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>m</mi></msup><annotation encoding="application/x-tex">\mathbb R^m</annotation></semantics></math> to gradients in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>n</mi></msup><annotation encoding="application/x-tex">\mathbb R^n</annotation></semantics></math>?</p>
<p>It is <em>technically</em> possible to do gradient descent on these things directly, if the current value of our parameters is always a finite support function then we can add the gradients pointwise. This more or less amounts to an architecture that by design will memorise its training data - it can <em>only</em> overfit.</p>
<p>There is something much smarter we can do, which is to replace our optimiser with an entire other supervised learning architecture. We parameterise the function space <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>‚Ñù</mi><mi>m</mi></msup><mo>‚Üí</mo><msup><mi>‚Ñù</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbb R^m \to \mathbb R^n</annotation></semantics></math> using a choice of architecture and parameter space <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>‚Ñù</mi><mi>p</mi></msup><annotation encoding="application/x-tex">\mathbb R^p</annotation></semantics></math>, and when we receive a function gradient - that is a list of pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><msup><mi>b</mi><mo>‚Ä≤</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b')</annotation></semantics></math> - we do our own run of supervised learning on it to optimise our own parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>. And so our free lunch has evaporated in front of our eyes, and we are back to doing ordinary deep learning with extra steps.</p>
<p>I find it plausible that this idea could still have useful applications, in the same way that function types themselves are still useful even though we could have just worked in a Turing-complete language without functions instead. For example, it would allow us to make use of all of the basic functional programming design patterns like mapping and filtering when implementing our architectures, letting the underlying autodiff framework figure out the right thing to do instead of having to unroll everything manually.</p>
<p>How practical this actually is right now depends heavily on how easy it would be to hack this method on top of an existing autodiff framework, which is something we haven‚Äôt thought much about yet. My best guess is that making it performant would really require a whole new compute kernel that is able to handle reducing (ie. recursively folding over) lists of suspended gradients, and that this is possible but best left to somebody who knows what they are doing with kernel programming and takes on the task of developing a serious 21st-century autodiff framework that isn‚Äôt balanced on top of ancient Fortran code and a programming paradigm that is 50 years out of date.</p>
<p>The thing that currently excites me the most about this is that when we have function types we can simulate continuation passing style using a <a href="https://hackage-content.haskell.org/package/mtl-2.3.2/docs/Control-Monad-Cont.html">continuation monad</a>, and so a language with function types can be used as an intermediate compiler target for a language with complex control flow features like throw/catch. What would autodiff through throw/catch look like? I have no idea, but it could be interesting to find out.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>That is not to say the tensor product can‚Äôt be given any universal property at all. My favourite is to characterise it as the fibrewise opposite of a cartesian product.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2"><p>It happens to also be cartesian closed, in an <em>extremely</em> non-obvious way, see the paper <a href="https://www.cs.ox.ac.uk/people/samuel.staton/papers/cie10.pdf">Higher order containers</a>. That structure plays no role for us.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3"><p>There is some interesting differential geometry going on here that I only partially understand.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
