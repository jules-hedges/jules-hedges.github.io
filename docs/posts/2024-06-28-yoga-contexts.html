<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - The yoga of contexts I</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>The yoga of contexts I</h1>
            <article>
    <section class="header">
        Posted on June 28, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/06/28/yoga-contexts/">X-posted on the CyberCat Institute blog</a>)</p>
<p>Suppose we have some category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, whose morphisms are some kind of <em>processes</em> or <em>systems</em> that we care about. We would like to be able to talk about <em>contexts</em> (or <em>environments</em>) in which these processes or systems can be located.</p>
<p>This post is to finally write part of the lore of categorical cybernetics that I’ve been working out on the backburner for a few years, and I’ve talked about in front of various audiences a few times. I never thought it was quite compelling enough to write a paper about it, but it’s been part of my bag of tricks for a while, for example playing a central role in my <a href="https://julesh.com/videos/">lecture series on compositional game theory</a>. In the meantime, similar ideas have been invented a few times in applied category theory, most notably being taken further for talking about <a href="https://arxiv.org/abs/2402.02997">quantum supermaps</a>.</p>
<h2 id="contexts-in-a-category">Contexts in a category</h2>
<p>Topologically, we draw morphisms of our category as nodes, which have a hole <em>outside</em> but no hole <em>inside</em> (that is to say they are really point-like, despite how we conventionally draw them) - and dually, we draw contexts as diagram elements that have a hole <em>inside</em> but no hole <em>outside</em>.</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img1.png" /></p>
<p>Being good category theorists, we choose not to say what a context <em>is</em> but how it <em>transforms</em>, which will lead to being able to define them via additional structure we can equip our categories with. If we have a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math>, and we have morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><msup><mi>X</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">f : X \to X'</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">g : Y' \to Y</annotation></semantics></math>, we should be able to <em>demote</em> these morphisms into being part of an extended environment for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">X' \to Y'</annotation></semantics></math>:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img2.png" /></p>
<p>By asking that demoting twice gives the same result as demoting a composite, and the order of demoting on the domain and codomain doesn’t matter, we end up inventing the following definition: A <em>system of contexts</em> for a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝒞</mi><mo accent="true">¯</mo></mover><mo>:</mo><mi>𝒞</mi><mo>×</mo><msup><mi>𝒞</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\overline{\mathcal C} : \mathcal C \times \mathcal C^{\mathrm{op}} \to \mathbf{Set}</annotation></semantics></math>, and a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math> is an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝒞</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\overline{\mathcal C} (X, Y)</annotation></semantics></math>.</p>
<p>Things get much more interesting when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is not just a category but a symmetric monoidal category, as is virtually always the case in any applied domain. Our first guess might be to replace the functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> with some kind of monoidal functor. <em>Lax</em> monoidal (for the cartesian monoidal product on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>) turns out to be probably what we want - this says that if we have a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math> and one for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">X' \to Y'</annotation></semantics></math> we can compose them to get a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊗</mo><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><mi>Y</mi><mo>⊗</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">X \otimes X' \to Y \otimes Y'</annotation></semantics></math>, but this operation is not necessarily reversible. Topologically this is a bit subtle, and says we can <em>bridge</em> 2 holes with a single morphism:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img3.png" /></p>
<p>We probably get away with this because we are assuming everything is symmetric monoidal. I sometimes think of holes as <em>anti-nodes</em> that we can slide around as though they are nodes. This part of the definition has an odd status right now: it seems that we can virtually always get it in practice, and it plays a role in the theory, but I have never actually deployed the lax monoidal structure of contexts while doing any applied work.</p>
<p>In any case, this is not enough to describe contexts in a symmetric monoidal category, so we need to go back to first principles.</p>
<h2 id="the-yoga-of-contexts">The yoga of contexts</h2>
<p>Suppose we have a symmetric monoidal category and we have a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊗</mo><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><mi>Y</mi><mo>⊗</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">X \otimes X' \to Y \otimes Y'</annotation></semantics></math>, and suppose we have a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math>. Similarly to before, we should be able to <em>demote</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> into the context, obtaining a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>′</mo></msup><mo>→</mo><msup><mi>Y</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">X' \to Y'</annotation></semantics></math>:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img4.png" /></p>
<p>I wrote this definition in section 9 of <a href="https://arxiv.org/abs/1904.11287">The Game Semantics of Game Theory</a>. But it turns out this isn’t the best way to write it: it’s enough to be able to demote an identity morphism, with an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>𝒞</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>Z</mi><mo>⊗</mo><mi>X</mi><mo>,</mo><mi>Z</mi><mo>⊗</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mover><mi>𝒞</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\overline{\mathcal C} (Z \otimes X, Z \otimes Y) \to \overline{\mathcal C} (X, Y)</annotation></semantics></math>:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img5.png" /></p>
<p>A category theorist would call this a (monoidal) <em>costrength</em> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝒞</mi><mo accent="true">¯</mo></mover><annotation encoding="application/x-tex">\overline{\mathcal C}</annotation></semantics></math>, although I find it useful to think of it as a kind of <em>tensor contraction</em>.</p>
<p>But there’s another way to think about this whole thing. Given a symmetric monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, a <em>comb</em> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a diagram element with 1 hole on the inside and 1 hole on the outside:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img6.png" /></p>
<p>(Note, drawing them with this “comb” shape is enough because our ambient category is symmetric. In a planar setting, we would actually have to puncture a box with a hole.)</p>
<p>Concretely, a comb consists of a pair of morphisms coupled through a “residual” wire - but by drawing a box around it, we lose the ability to distinguish combs that differ by sliding a morphism between the front and back along the residual wire:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img7.png" /></p>
<p>This turns out to be exactly the the definition of an <em>optic</em> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> - I think of combs as one <em>syntactic</em> presentation (among several others) of the <em>semantic</em> concept of an optic in a category. There is a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> whose objects are pairs of objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, and whose morphisms are combs. Whereas string diagrams in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> compose left-to-right, these “comb diagrams” in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> compose <em>outside-in</em>, like an operad:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img8.png" /></p>
<p>We also get a symmetric monoidal product on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> that encompasses what I said earlier about sliding holes around. Now we get an alternative definition of context: it’s a <em>generalised state</em> of optics. That is to say, it’s an <em>ultimate outside</em>, which can be transformed by attaching a comb to the inside of the hole:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img9.png" /></p>
<p>If we do this, the properties we had to demand of the co-strength map get absorbed into the quotient defining optics.</p>
<p>What is a “generalised state”? A <em>state</em> in a monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is a morphism from the monoidal unit, and a <em>generalised</em> state is something that transforms like a state: an element of some lax monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C \to \mathbf{Set}</annotation></semantics></math>. That is to say: if we have a generalised state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math>, we get a pushforward state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mo>*</mo></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f_* (x)</annotation></semantics></math>; and if we have generalised states <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>, we get a state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \otimes y</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊗</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \otimes Y</annotation></semantics></math>.</p>
<p>So now we have 2 different definitions of a system of contexts: as a lax monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>×</mo><msup><mi>𝒞</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C \times \mathcal C^{\mathrm{op}} \to \mathbf{Set}</annotation></semantics></math> equipped with a co-strength map, or as a lax monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math>. Fortunately, these definitions turn out to be equivalent: it’s a dual of the <a href="https://arxiv.org/abs/2001.07488">profunctor representation theorem</a>. The normal version of this theorem says that <em>Tambara modules</em> - endo-profunctors on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> equipped with a strength map - are equivalent to functors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)^{\mathrm{op}} \to \mathbf{Set}</annotation></semantics></math>. It turns out that a Tambara module on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝒞</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><annotation encoding="application/x-tex">\mathcal C^{\mathrm{op}}</annotation></semantics></math> is the same thing as a Tambara module, which conveniently frees up the name <em>Tambara co-module</em> to be used for this thing.</p>
<p>(A word of warning: the paper I linked defines “<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math>” to be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)^\mathrm{op}</annotation></semantics></math>, which means they say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math> when they mean <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)^{\mathrm{op}} \to \mathbf{Set}</annotation></semantics></math> and vice versa.)</p>
<p>As a personal anecdote, at different points I’ve convinced myself that both of these definitions were the correct definition of “system of contexts”, before realising that they were equivalent by the profunctor representation theorem - this led to me getting some quite good, graphical intuition for this otherwise notoriously abstract theorem.</p>
<p>Some time after working out the last part of this, I learned about the existence of <a href="https://www.sciencedirect.com/science/article/pii/S0304397512000163">this paper</a> by Hermida and Tennent, which finally backed up my intuition behind my definition of generalised states by formulating a universal construction forcing them to become actual states. Incredibly this construction itself also falls squarely in the small cluster of methods we call categorical cybernetics, which caps off the whole thing very nicely. I touched on this construction in <a href="https://cybercat.institute/2024/02/22/iteration-optics/">this blog post</a>, and perhaps I’ll have more to say about it later too.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Often we don’t need generalised states, and ordinary states are enough: that’s when we take the representable functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>𝒞</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C (I, -) : \mathcal C \to \mathbf{Set}</annotation></semantics></math>, which is indeed lax monoidal. (General representable functors on a monoidal category are <em>not</em> lax monoidal in general!)</p>
<p>This leads to what I call the “representable system of contexts” for a symmetric monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>: it’s the one described by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C) (I, -)</annotation></semantics></math>, where the monoidal unit of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mo>,</mo><mi>I</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(I, I)</annotation></semantics></math>. What this ends up saying is that a context for morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is an equivalence class of pairs of a state and a costate in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, coupled through a residual:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img10.png" /></p>
<p>This turns out (in a non-trivial way) to be equivalent to the definition of context used for both <a href="https://arxiv.org/abs/1603.04641">deterministic</a> and <a href="https://compositionality-journal.org/papers/compositionality-5-9/">Bayesian</a> open games. In those cases, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is itself a category of optics, making systems of contexts examples of <em>double optics</em>. Iterating the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (-)</annotation></semantics></math> construction can be usefully depicted in 2 different ways: as 1-hole combs in a bidirectional category:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img11.png" /></p>
<p>or as 3-hole combs:</p>
<p><img src="../assets/posts/2024-06-28-yoga-contexts/img12.png" /></p>
<p>Moving back and forth between these equivalent views of the iterated optic construction is a key part of the yoga of contexts as it applies to categorical cybernetics.</p>
<p>An example of a non-representable system of contexts is the “iteration functor” I talked about in <a href="https://cybercat.institute/2024/02/22/iteration-optics/">this post</a>. It’s closely related to the <em>algebra of Moore machines</em> which plays a major role in David Jaz Myers’ book on <a href="http://davidjaz.com/Papers/DynamicalBook.pdf">categorical systems theory</a>.</p>
<p>But, the actual reason this is a blog post and not a paper is that I don’t have any really compelling examples outside of categorical cybernetics. But I’ll talk more about my struggles with that in part II, where I’ll build a category of “behaviours in context” given a system of contexts, generalising the construction of open games.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
