<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Selection functions and lenses</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Selection functions and lenses</h1>
            <article>
    <section class="header">
        Posted on March 30, 2021
        
    </section>
    <section>
        <p>I’ve been wondering for several years how selection functions and lenses relate to each other, I felt intuitively that there should be some connection – and not just because they both show up in the foundations of game theory. Last night I came up with an answer, which isn’t a complete answer but looks like the starting point for a complete answer.</p>
<p>A selection function is a function of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒥</mi><mi>R</mi></msub><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>→</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathcal J_R X = (X \to R) \to X</annotation></semantics></math>. The canonical example is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>arg</mi><mo>⁡</mo></mrow><mrow><mi>max</mi><mo>⁡</mo></mrow><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>→</mo><mi>ℝ</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\arg\max : (X \to \mathbb R) \to X</annotation></semantics></math>, after choosing a single maximiser for every function (say that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is a finite set to avoid worrying about existence of a maximiser). <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝒥</mi><mi>R</mi></msub><annotation encoding="application/x-tex">\mathcal J_R</annotation></semantics></math> is a strong monad, closely related to the continuation monad, with a highly non-obvious monad structure. Combining argmaxen using the monadic bind makes the <a href="https://en.wikipedia.org/wiki/Backward_induction">backward induction</a> algorithm from game theory fall out of pure category theory – see a string of papers by Martín Escardó and Paulo Oliva, especially <a href="https://www.eecs.qmul.ac.uk/~pbo/papers/paper032.pdf">Sequential games and optimal strategies</a> for a good introduction.</p>
<p>Meanwhile, the category of lenses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lens}</annotation></semantics></math> has as objects pairs of sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, R)</annotation></semantics></math>, and its morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, S) \to (Y, R)</annotation></semantics></math> consist of pairs of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">v : X \to Y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>:</mo><mi>X</mi><mo>×</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">u : X \times R \to S</annotation></semantics></math>. The identity lens on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, S)</annotation></semantics></math> consists of an identity function and a projection, and the composition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>u</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(v_1, u_1) : (X, S) \to (Y, R)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Z</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(v_2, u_2) : (Y, R) \to (Z, Q)</annotation></semantics></math> consists of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">v (x) = v_2 (v_1 (x))</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>u</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>q</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">u (x, q) = u_1 (x, u_2 (v_1 (x), q))</annotation></semantics></math>. Lenses also play a deep role in the foundations of game theory, via <a href="https://arxiv.org/abs/1603.04641">open games</a>.</p>
<p>What I noticed is that there is a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒥</mi><mo>:</mo><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal J : \mathbf{Lens} \to \mathbf{Set}</annotation></semantics></math>, taking the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, R)</annotation></semantics></math> to the set of selection functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒥</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>𝒥</mi><mi>R</mi></msub><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>→</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathcal J (X, R) = \mathcal J_R X = (X \to R) \to X</annotation></semantics></math>. Given a selection function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><msub><mi>𝒥</mi><mi>S</mi></msub><mi>X</mi></mrow><annotation encoding="application/x-tex">\varepsilon : \mathcal J_S X</annotation></semantics></math> and a lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(v, u) : (X, S) \to (Y, R)</annotation></semantics></math>, we can “push forward” the selection function along the lens, to obtain a selection function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒥</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msub><mi>𝒥</mi><mi>R</mi></msub><mi>Y</mi></mrow><annotation encoding="application/x-tex">\mathcal J (v, u) (\varepsilon) : \mathcal J_R Y</annotation></semantics></math> using the formula <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒥</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>ε</mi><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal J (v, u) (\varepsilon) (k) = v (\varepsilon (\lambda x . u (x, k (v (x)))))</annotation></semantics></math>. This turns out to be functorial – pushing forward a selection function along the identity lens does nothing, and pushing forward a selection function along two lenses is the same as pushing forward along the composed lens.</p>
<p>The slick way to see this is to notice that there is a natural isomorphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>→</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>X</mi><mo>≅</mo><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐋</mi><mi>𝐞</mi><mi>𝐧</mi><mi>𝐬</mi></mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X \to R) \to X \cong \mathbf{Lens} ((X, R), (1, 1)) \to \mathbf{Lens} ((1, 1), (X, R))</annotation></semantics></math> – in other words, a selection function is a way to turn costates into states in the category of lenses. These two representable functors already play a <a href="https://arxiv.org/abs/1711.07059">deep role</a> in open games.</p>
<p>I wanted to write a short blog post just to explain this much; how this connects to the monad structure of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝒥</mi><mi>R</mi></msub><annotation encoding="application/x-tex">\mathcal J_R</annotation></semantics></math>, and what are the implications for game theory, remain to be seen. To me, this functor feels close to the beating heart of game theory.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
