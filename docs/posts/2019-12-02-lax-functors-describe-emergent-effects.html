<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Lax functors describe emergent effects</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Lax functors describe emergent effects</h1>
            <article>
    <section class="header">
        Posted on December  2, 2019
        
    </section>
    <section>
        <p>In this post I’ll describe something that’s kind of common knowledge among applied category theorists, that when you describe behaviour via a (pseudo)functor to the category of relations, emergent effects are described by the failure of that functor to be strong, ie. to be an actual functor. This is more or less in <a href="https://arxiv.org/abs/1803.05316">Seven Sketches</a> (Fong and Spivak say “generative effects”, which as far as I can tell is an exact synonym for emergent effects), but I’ll write it in one place and in my own words.</p>
<p>Suppose we have a domain-specific category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>. It’s hopefully monoidal and most likely a hypergraph category, but the basic idea of what I’m saying applies just to the category structure. The morphisms of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> are open systems of some sort, the objects describe the open boundaries that a system can have, and composition describes coupling two systems together along a common boundary. The standard sledgehammer for building categories like this is <a href="https://arxiv.org/abs/1502.00872">decorated cospans</a>, with <a href="https://arxiv.org/abs/1911.04630">structured cospans</a> as a closely related new alternative.</p>
<p>Now suppose we define an operation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>𝒞</mi><mo>→</mo><mrow><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow></mrow><annotation encoding="application/x-tex">F : \mathcal C \to \mathbf{Rel}</annotation></semantics></math>, which we think of as describing ‘behaviour’, understood broadly. Every object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is sent to a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (x)</annotation></semantics></math> of behaviours that the boundaries can exhibit. Every morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \to y</annotation></semantics></math> is set to a subset <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (f) \subseteq F (x) \times F (y)</annotation></semantics></math>, where we think of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b) \in F (f)</annotation></semantics></math> as saying that, if we have the system <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>, it is possible to simultaneously observe the behaviour <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> on its left boundary and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> on its right boundary.</p>
<p>Now think about what happens when we couple a pair of systems <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f : x \to y</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>y</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">g : y \to z</annotation></semantics></math> along their common boundary, yielding the complex system <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">fg : x \to z</annotation></semantics></math>. We now have three sets of behaviours: the behaviours <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (f) \subseteq F (x) \times F (y)</annotation></semantics></math> of the first component, the behaviours <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (g) \subseteq F (y) \times F (z)</annotation></semantics></math> of the second component, and the behaviours <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (fg) \subseteq F (x) \times F (z)</annotation></semantics></math> of the complex.</p>
<p>Under reasonable conditions, it is the case that every pair of behaviours of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math> that are consistent, in the sense that they agree on the behaviour of the common boundary, yield a behaviour of the complex system. (This can certainly fail – I can think of one example involving Nash equilibria of games under a naive composition like adding payoffs – but if it fails you should probably give up and try something different.) The behaviours on the outer boundaries that arise from behaviours of the components that are consistent on the middle boundary is exactly described by the composition in the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><annotation encoding="application/x-tex">\mathbf{Rel}</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>∣</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> and </mtext><mspace width="0.333em"></mspace></mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> for some </mtext><mspace width="0.333em"></mspace></mrow><mi>b</mi><mo>∈</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex"> F (f) F (g) = \{ (a, c) \mid (a, b) \in F (f) \text{ and } (b, c) \in F (g) \text{ for some } b \in F (y) \} </annotation></semantics></math></p>
<p>So the reasonable condition we imposed on behaviours is that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> F (f) F (g) \subseteq F (fg) </annotation></semantics></math></p>
<p>which is the condition that F is a <em>lax (pseudo)functor</em> (thinking of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><annotation encoding="application/x-tex">\mathbf{Rel}</annotation></semantics></math> as a fairly boring 2-category).</p>
<p>If we always have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (f) F (g) = F (fg)</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> is a functor. This condition says that every possible behaviour of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math> arises in this way from behaviours of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math> that are consistent along <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>. This is a very strong requirement in practice, and generally fails. (An example of it failing is <a href="https://arxiv.org/abs/1808.05415">reachability in Petri nets</a>; I have an in-progress example involving smooth optimisation.)</p>
<p>Failure of a lax functor to be a functor is caused by <em>emergent effects</em>, that is to say, behaviours of a complex system that do not come from possible behaviours of the components. Under this very general setup, we can give a precise definition of an emergent behaviour of a complex system <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">fg</annotation></semantics></math>: it is as an element of the set</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>\</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> F (fg) \setminus F (f) F (g) </annotation></semantics></math></p>
<p>This much is what I expect most applied category theorists to know, so I’m writing for everyone else. Now I’m going to end with a difficult challenge for ACT.</p>
<p>It’s a good achievement to have such a clean definition of emergent effects, but I am worried that we can’t follow it up. Instead of saying “huh, my class of systems exhibits emergent effects” and moving on, can we say more? What I would like is to be able to associate, to a given lax (probably monoidal, hypergraph) pseudofunctor into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><annotation encoding="application/x-tex">\mathbf{Rel}</annotation></semantics></math> (or variants such as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐑</mi><mi>𝐞</mi><mi>𝐥</mi></mrow><annotation encoding="application/x-tex">\mathbf{LinRel}</annotation></semantics></math>), some kind of object that encodes some useful knowledge about its failure to be a functor. Ideally, something that makes it easier to calculate (or otherwise do something with) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (fg)</annotation></semantics></math> if we know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (f)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (g)</annotation></semantics></math>. Algebraic topology has a bunch of machinery that seems like it might be able to do this sort of thing (especially if we start imposing some reasonable extra conditions on our category of open systems <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> or on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>), but I don’t understand it well enough.</p>
<p><strong>Edit</strong>: <a href="https://elieadam.com/eadam_PhDThesis.pdf">Elie Adam’s PhD thesis</a> looks closely related to this, but is built on different foundations (the terms “pseudo” and “lax” do not match in the text). Hopefully one of these years I’ll have some time to think about how it fits together.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
