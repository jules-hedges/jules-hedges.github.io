<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Enriched closed lenses</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Enriched closed lenses</h1>
            <article>
    <section class="header">
        Posted on April 12, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/04/12/enriched-closed-lenses/">X-posted on the CyberCat Institute blog</a>)</p>
<p>I’m going to record something that I think is known to everyone doing research on categorical cybernetics, but I don’t think has been written down somewhere: an even more general version of mixed optics that replaces the backwards actegory with an enrichment. With it, I’ll make sense of a curious definition appearing in <a href="https://homepages.inf.ed.ac.uk/gdp/publications/compiler-forest.pdf">The Compiler Forest</a>.</p>
<h1 id="actegories-and-enrichments">Actegories and enrichments</h1>
<p>An <strong>actegory</strong> consists of a monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math>, a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>•</mi><mo>:</mo><mi>ℳ</mi><mo>×</mo><mi>𝒞</mi><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">\bullet : \mathcal M \times \mathcal C \to \mathcal C</annotation></semantics></math> that behaves like an “external product”: namely that it’s equipped with coherent isomorphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>•</mo><mi>X</mi><mo>≅</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">I \bullet X \cong X</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>⊗</mo><mi>N</mi><mo stretchy="false" form="postfix">)</mo><mo>•</mo><mi>X</mi><mo>≅</mo><mi>M</mi><mo>•</mo><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>•</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(M \otimes N) \bullet X \cong M \bullet (N \bullet X)</annotation></semantics></math>.</p>
<p>An <strong>enriched category</strong> consists of a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, a monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math> and a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>−</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">]</mo><mo>:</mo><msup><mi>𝒞</mi><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>×</mo><mi>𝒞</mi><mo>→</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">[-, -] : \mathcal C^\mathrm{op} \times \mathcal C \to \mathcal M</annotation></semantics></math> that behaves like an “external hom” (I’m not going to write down what this means because it’s more complicated).</p>
<p>There’s a very close relationship between actegories and enrichments, to the point that I consider them different perspectives on the same idea. This is the <em>final form</em> of the famous tensor-hom adjunction, aka. currying. (I learned this incredible fact from Matteo Capucci, and I have no idea where it’s written down, although it’s definitely written down somewhere.)</p>
<p>A <strong>tensored enrichment</strong> is one where every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>Z</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">]</mo><mo>:</mo><mi>𝒞</mi><mo>→</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">[Z, -] : \mathcal C \to \mathcal M</annotation></semantics></math> has a left adjoint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mo>•</mo><mi>X</mi><mo>:</mo><mi>ℳ</mi><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">- \bullet X : \mathcal M \to \mathcal C</annotation></semantics></math>. Allowing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math> to vary results in a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>•</mi><annotation encoding="application/x-tex">\bullet</annotation></semantics></math> which (nontrivial theorem) is always an actegory.</p>
<p>A <strong>closed actegory</strong> is one where every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mo>•</mo><mi>Z</mi><mo>:</mo><mi>ℳ</mi><mo>→</mo><mi>𝒞</mi></mrow><annotation encoding="application/x-tex">- \bullet Z : \mathcal M \to \mathcal C</annotation></semantics></math> has a right adjoint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>Z</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">]</mo><mo>:</mo><mi>𝒞</mi><mo>→</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">[Z, -] : \mathcal C \to \mathcal M</annotation></semantics></math>. Allowing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math> to vary results in a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>−</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[-, -]</annotation></semantics></math> which (nontrivial theorem) is always an enrichment.</p>
<p>So, closed actegories and tensored enrichments are equivalent ways of defining the same thing, namely a monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math> and category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> equipped with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>•</mi><annotation encoding="application/x-tex">\bullet</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>−</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[-, -]</annotation></semantics></math> related by a tensor-hom adjunction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>•</mo><mi>Z</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>ℳ</mi><mo stretchy="false" form="prefix">(</mo><mi>Z</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal C (X \bullet Z, Y) \cong \mathcal M (Z, [X, Y])</annotation></semantics></math>.</p>
<h1 id="parametrisation">Parametrisation</h1>
<p>Given an actegory, we can define a bicategory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_\mathcal M (\mathcal C)</annotation></semantics></math>, whose objects are objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and 1-cells are pairs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">M : \mathcal M</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>•</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f : \mathcal C (M \bullet X, Y)</annotation></semantics></math>. We can also define a bicategory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Copara}_\mathcal M (\mathcal C)</annotation></semantics></math>, whose objects are objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and 1-cells are pairs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">M : \mathcal M</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>M</mi><mo>•</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f : \mathcal C (X, M \bullet Y)</annotation></semantics></math>.</p>
<p>Given an enriched category, we can define a bicategory <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_\mathcal M (\mathcal C)</annotation></semantics></math>, whose objects are objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and morphisms are pairs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><mi>ℳ</mi></mrow><annotation encoding="application/x-tex">M : \mathcal M</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>ℳ</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f : \mathcal M (M, [X, Y])</annotation></semantics></math>. If this is a tensored enrichment then the two definitions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_\mathcal M (\mathcal C)</annotation></semantics></math> are equivalent.</p>
<p>In all of these cases we are locally fibred over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math>, and I will write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_\mathcal M (\mathcal C) (X, Y) (M)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Copara}_\mathcal M (\mathcal C) (X, Y) (M)</annotation></semantics></math> for the set of co/parametrised morphisms with a fixed parameter type.</p>
<p>It’s not possible to define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Copara}_\mathcal M (\mathcal C)</annotation></semantics></math> for an enrichment. There’s a very slick common generalisation of actegories and enrichments called a <a href="https://ncatlab.org/nlab/show/locally+graded+category">locally graded category</a>, which is a category enriched in presheaves with Day convolution. There’s also a very slick definition of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><annotation encoding="application/x-tex">\mathbf{Para}</annotation></semantics></math> for a locally graded category. I’d like to know, for exactly which locally graded categories is possible to define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><annotation encoding="application/x-tex">\mathbf{Copara}</annotation></semantics></math>?</p>
<h1 id="mixed-optics">Mixed optics</h1>
<p>If we have two actegories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>,</mo><mi>𝒟</mi></mrow><annotation encoding="application/x-tex">\mathcal C, \mathcal D</annotation></semantics></math> that share the same acting category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math> then we can define <strong>mixed optics</strong>, which first appeared in <a href="https://compositionality-journal.org/papers/compositionality-6-1/">Profunctor Optics: A Categorical Update</a>. This is a 1-category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo>,</mo><mi>𝒟</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic}_\mathcal M (\mathcal C, \mathcal D)</annotation></semantics></math> whose objects are pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math> of an object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and an object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒟</mi><annotation encoding="application/x-tex">\mathcal D</annotation></semantics></math>, and a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> is an element of the coend</p>
<p><span class="math display">$$ $\int^{M : \mathcal M} \mathbf{Copara}_\mathcal M (\mathcal C) (X, Y) (M) \times \mathbf{Para}_\mathcal M (\mathcal D) (Y', X') (M) $$</span></p>
<p>There’s a slightly more general definition called “weighted optics” that appears in <a href="https://arxiv.org/abs/2403.13001">Bruno’s thesis</a> and was used very productively there, which replaces <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math> with two monoidal categories related by a Tambara module. I think that it’s an orthogonal generalisation to the one I’m about to do here.</p>
<h1 id="enriched-closed-lenses">Enriched closed lenses</h1>
<p>Putting together everything I’ve just said, the next step is clear. If we have categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>,</mo><mi>𝒟</mi></mrow><annotation encoding="application/x-tex">\mathcal C, \mathcal D</annotation></semantics></math> and a monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math>, with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math> acting on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒟</mi><annotation encoding="application/x-tex">\mathcal D</annotation></semantics></math> enriched in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℳ</mi><annotation encoding="application/x-tex">\mathcal M</annotation></semantics></math>, then we can still define <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo>,</mo><mi>𝒟</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic}_\mathcal M (\mathcal C, \mathcal D)</annotation></semantics></math> in exactly the same way, replacing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐏</mi><mi>𝐚</mi><mi>𝐫</mi><mi>𝐚</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_\mathcal M (\mathcal D)</annotation></semantics></math> with its enriched version. But now, unlike before, we can use the ninja Yoneda lemma to eliminate the coend and get</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐎</mi><mi>𝐩</mi><mi>𝐭</mi><mi>𝐢</mi><mi>𝐜</mi></mrow><mi>ℳ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝒞</mi><mo>,</mo><mi>𝒟</mi><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>≅</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">]</mo><mo>•</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathbf{Optic}_\mathcal M (\mathcal C, \mathcal D) \left( \binom{X}{X'}, \binom{Y}{Y'} \right) \cong \mathcal C (X, [Y', X'] \bullet Y) </annotation></semantics></math></p>
<p>In general I refer to optics that can be defined without type quantification as <em>lenses</em>, and so this is an <strong>enriched closed lens</strong>. It’s the <em>final form</em> of “linear lenses”, the version of lenses that is defined like <code>Lens s t a b = s -&gt; (a, b -&gt; t)</code>.</p>
<h1 id="into-the-compiler-forest">Into the compiler forest</h1>
<p>Section 5 of <a href="https://homepages.inf.ed.ac.uk/gdp/publications/compiler-forest.pdf">The Compiler Forest</a> by Budiu, Galenson and Plotkin has a <em>very</em> interesting definition in it. They have a cartesian closed category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> (whose internal hom I’ll write as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo><annotation encoding="application/x-tex">\to</annotation></semantics></math>) and a strong monad <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> on it, and they define a category whose objects are pairs of objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and whose morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>→</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> are morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>×</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>→</mo><mi>T</mi><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f : X \to T (Y \times (Y' \to T X'))</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>.</p>
<p>They also nail an intuition for lenses that I use constantly and I haven’t seen written down anywhere else: problems go forwards, solutions go backwards.</p>
<p>Me and this definition have quite a history. It came to my attention while polishing <a href="https://compositionality-journal.org/papers/compositionality-5-9/">Bayesian Open Games</a> for submission. For a while, I thought that it was equivalent to optics in the kleisli category of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>, and we’d wasted a years of our lives trying to understand optics (this being around 2018, when optics were still a niche idea). Then, for a while I thought that the paper made a mistake and these things don’t compose associatively. Now I’ve made peace: I think their definition is <em>conceptually</em> subtly wrong in a way that makes no difference in practice, and I can say very precisely how it relates to kleisli optics.</p>
<p>There is an action of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T)</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>•</mo><mi>X</mi><mo>=</mo><mi>M</mi><mo>⊗</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">M \bullet X = M \otimes X</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊗</mi><annotation encoding="application/x-tex">\otimes</annotation></semantics></math> is the tensor product of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T)</annotation></semantics></math> which on objects is given by the product <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>×</mi><annotation encoding="application/x-tex">\times</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>. That’s the actegory generated by the strong monoidal embedding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒞</mi><mo>↪</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal C \hookrightarrow \mathrm{Kl} (T)</annotation></semantics></math>. There is also an enrichment of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T)</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mi>X</mi><mo>→</mo><mi>T</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">[X, Y] = X \to T Y</annotation></semantics></math>. This action and enrichment are adjoint to each other: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>⊗</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>M</mi><mo>→</mo><mi>T</mi><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T) (M \otimes X, Y) \cong \mathcal C (X, M \to TY)</annotation></semantics></math>.</p>
<p>The category defined in Compiler Forest turns out to be equivalent to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mrow><mi>𝒞</mi></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{Optic}_\mathcal C (\mathrm{Kl} (T), \mathrm{Kl} (T)) </annotation></semantics></math></p>
<p>whose forwards pass is given by the action of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T)</annotation></semantics></math> and whose backwards pass is given by the enrichment of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Kl} (T)</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>. Its hom-sets are given by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mrow><mi>𝒞</mi></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \mathrm{Optic}_\mathcal C (\mathrm{Kl} (T), \mathrm{Kl} (T)) \left( \binom{X}{X'}, \binom{Y}{Y'} \right) </annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mo>∫</mo><mrow><mi>M</mi><mo>:</mo><mi>𝒞</mi></mrow></msup><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>×</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>,</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>→</mo><mi>T</mi><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> = \int^{M : \mathcal C} \mathcal C (X, T (M \times Y)) \times \mathcal C (M, Y' \to T X') </annotation></semantics></math></p>
<p>which Yoneda-reduces to the definition in the paper.</p>
<p>Even though the action and enrichment are adjoint, this is <em>not</em> the same as optics in the klesli category:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mrow><mi>𝒞</mi></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>≆</mo><msub><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mrow><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{Optic}_\mathcal C (\mathrm{Kl} (T), \mathrm{Kl} (T)) \not\cong \mathrm{Optic}_{\mathrm{Kl} (T)} (\mathrm{Kl} (T), \mathrm{Kl} (T)) </annotation></semantics></math></p>
<p>where the hom-sets of the latter are defined by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mrow><mrow><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>′</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \mathrm{Optic}_{\mathrm{Kl} (T)} (\mathrm{Kl} (T), \mathrm{Kl} (T)) \left( \binom{X}{X'}, \binom{Y}{Y'} \right) </annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><msup><mo>∫</mo><mrow><mi>M</mi><mo>:</mo><mrow><mi mathvariant="normal">K</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>×</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>𝒞</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>×</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>,</mo><mi>T</mi><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> = \int^{M : \mathrm{Kl} (T)} \mathcal C (X, T (M \times Y)) \times \mathcal C (M \times Y', T X') </annotation></semantics></math></p>
<p>This equivalence, between optics whose backwards passes are an adjoint action or enrichment, would be a completely reasonable-looking lemma but it just isn’t true!</p>
<p>The difference between them is extremely subtle, though. The “proper” definition of kleisli optics identifies morphisms that agree up to sliding any kleisli morphism, whereas the definition in Compiler Forest only identifies morphisms that agree up to sliding pure morphisms of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒞</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>. So hom-sets of coend optics are a quotient of the hom-sets defined in Compiler Forest. While writing this up, I realised that most of this conclusion actually appears in section 4.9 of <a href="https://arxiv.org/abs/1809.00738">Riley’s original paper</a>.</p>
<p>As long as you don’t care about equality of morphisms - which in practice is never, because they are made of functions - the difference between them can be safely ignored. The only genuine reason to prefer kleisli optics is <a href="https://arxiv.org/abs/2209.09351">their better runtime performance</a>.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
