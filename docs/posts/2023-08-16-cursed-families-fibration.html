<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - The cursed families fibration</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/fonts.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <link rel="me" href="https://mathstodon.xyz/@julesh" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>The cursed families fibration</h1>
            <article>
    <section class="header">
        Posted on August 16, 2023
        
    </section>
    <section>
        <p>This post is describing a simple construction I worked out while trying to understand the <a href="https://bentnib.org/quantitative-type-theory.html">semantics of quantitative type theory</a>. It is a variant of the families fibration, a well known construction in category theory, which is sensitive to the way that sets are made out of elements, and allows fibres to overlap. Hence it is â€œcursedâ€, which is like <a href="https://ncatlab.org/nlab/show/principle+of+equivalence">evil</a> but more.</p>
<p>Letâ€™s begin by recalling how the families fibration works. For any category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, we can build a category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C)</annotation></semantics></math>. The objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C)</annotation></semantics></math> are set-indexed families in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>: that is, a pair of an index set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathcal C)</annotation></semantics></math>. A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A) \to (Y, B)</annotation></semantics></math> is a pair of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family of morphisms of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal C, A (x) \to B (f (x))</annotation></semantics></math>.</p>
<p>There is a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math> which forgets everything except the index set. This functor turns out to be a fibration. The fibre over a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is exactly <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ğ’</mi><mi>X</mi></msup><annotation encoding="application/x-tex">\mathcal C^X</annotation></semantics></math>, ie. the functor category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>â†’</mo><mi>ğ’</mi></mrow><annotation encoding="application/x-tex">X \to \mathcal C</annotation></semantics></math> when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> is seen as a discrete category.</p>
<p>Now letâ€™s specialise to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mo>=</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C = \mathbf{Set}</annotation></semantics></math>, so we are considering the fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \to \mathbf{Set}</annotation></semantics></math>. A magical property of the category of sets is that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mi>X</mi></msup><mo>â‰…</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mi>/</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}^X \cong \mathbf{Set} / X</annotation></semantics></math>. Letâ€™s go through how this equivalence works. In the forwards direction, we have an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathbf{Set})</annotation></semantics></math>, which we turn into its disjoint union equipped with the projection onto the index set, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆ‘</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\sum_{x \in X} A (x) \to X</annotation></semantics></math>. In the backwards direction, we have a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : X' \to X</annotation></semantics></math>, which we turn into an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family by inverse images: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>x</mi><mo>â€²</mo></msup><mo>âˆˆ</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>âˆ£</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A (x) = \{ x' \in X' \mid f(x') = x \}</annotation></semantics></math>. Both of these turn out to be functorial and define an equivalence of categories.</p>
<p>Doing this on the total category gives us an equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>â‰…</mo><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \cong \mathbf{Set}^\to</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> is the arrow category, whose objects are functions and morphisms are commuting squares. The equivalence looks basically the same: an object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A)</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math> goes to the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆ‘</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\sum_{x \in X} A(x) \to X</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math>, and the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : X' \to X</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> goes to the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>f</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><msub><mo stretchy="false" form="postfix">)</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, f^{-1} (x)_{x \in X})</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math>.</p>
<p>This extends to an equivalence of fibrations, where the families fibration corresponds to the codomain fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mo>:</mo><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{cod} : \mathbf{Set}^\to \to \mathbf{Set}</annotation></semantics></math>.</p>
<p>Ok, that concludes our very condensed recap of the families construction. Now letâ€™s make it <em>cursed</em>.</p>
<p>The objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> (fraktur is the appropriate font for a cursed object) are the same as the objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set})</annotation></semantics></math>: a pair of a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">A : X \to \mathrm{Ob} (\mathbf{Set})</annotation></semantics></math>. However, we restrict the morphisms (so we get a wide subcategory). A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A) \to (Y, B)</annotation></semantics></math> is a pair of a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed family functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>âˆ’</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x, -) : A (x) \to B (f (x))</annotation></semantics></math> satsifying an additional property: that if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>âˆˆ</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>âˆ©</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \in A (x_1) \cap A (x_2)</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>f</mi><mo>â€²</mo></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f' (x_1, a) = f' (x_2, a)</annotation></semantics></math>, and consequently, both are elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>âˆ©</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">B (f (x_1)) \cap B (f (x_2))</annotation></semantics></math>. (And if this intersection is empty then no morphism of this type can exist.)</p>
<p>This is fundamentally using the fact that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math> is untyped, and we can talk about the intersection of arbitrary sets.</p>
<p>The intuition is that morphisms are not allowed to use their knowledge of the index, unless it can be deduced from the rest of their input. Iâ€™ll go through a detailed example of this later.</p>
<p>Just as there is an equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ…</mi><mi>ğš</mi><mi>ğ¦</mi></mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>â‰…</mo><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{Fam} (\mathbf{Set}) \cong \mathbf{Set}^\to</annotation></semantics></math>, there is a cursed counterpart of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†’</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\to</annotation></semantics></math> that is equivalent to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math>. Iâ€™ll call this category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math>. An object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> is a pair of sets equipped with a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>âŠ†</mo><mi>X</mi><mo>Ã—</mo><msup><mi>X</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math>. A morphism from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>âŠ†</mo><mi>X</mi><mo>Ã—</mo><msup><mi>X</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>âŠ†</mo><mi>Y</mi><mo>Ã—</mo><msup><mi>Y</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">S \subseteq Y \times Y'</annotation></semantics></math> is a pair of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>â†’</mo><msup><mi>Y</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">f' : X' \to Y'</annotation></semantics></math> such that if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">x R x'</annotation></semantics></math> then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mi>S</mi><msup><mi>f</mi><mo>â€²</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f (x) S f' (x')</annotation></semantics></math>.</p>
<p>One perspective on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> is that itâ€™s the category of morphisms in the double category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ‘</mi><mi>ğ</mi><mi>ğ¥</mi></mrow><annotation encoding="application/x-tex">\mathbf{Rel}</annotation></semantics></math> whose proarrows are binary relations.</p>
<p>We can turn an object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, A)</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> into an object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> by taking the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆª</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cup_{x \in X} A (x)</annotation></semantics></math> together with the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>âŠ†</mo><mi>X</mi><mo>Ã—</mo><msub><mo>âˆª</mo><mrow><mi>x</mi><mo>âˆˆ</mo><mi>X</mi></mrow></msub><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R \subseteq X \times \cup_{x \in X} A (x)</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">x R x'</annotation></semantics></math> if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>â€²</mo></msup><mo>âˆˆ</mo><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x' \in A (x)</annotation></semantics></math>. Conversely, a binary relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>âŠ†</mo><mi>X</mi><mo>Ã—</mo><msup><mi>X</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq X \times X'</annotation></semantics></math> we can do the relational equivalent of inverse images to get the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>-indexed set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>x</mi><mo>â€²</mo></msup><mo>âˆˆ</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>âˆ£</mo><mi>x</mi><mi>R</mi><msup><mi>x</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">A (x) = \{ x' \in X' \mid x R x' \}</annotation></semantics></math>.</p>
<p>Both <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math> are fibred over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>, the latter being by the relational version of codomain, and the equivalence of categories <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><mo>â‰…</mo><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup></mrow><annotation encoding="application/x-tex">\mathfrak{Fam} \cong \mathbf{Set}^\leftrightarrow</annotation></semantics></math> extends to an equivalence of fibrations.</p>
<p>Here is a simple example, which was suggested by Zanzi. Given a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>, we have the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math> of lists, the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mi>n</mi></msup><annotation encoding="application/x-tex">X^n</annotation></semantics></math> of lists of length <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, and the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">X^{* \leq n}</annotation></semantics></math> of lists of length at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mi>n</mi></msup><annotation encoding="application/x-tex">X^n</annotation></semantics></math> are non-overlapping for distinct <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, that is to say, two lists of different lengths cannot be equal. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math> is in natural bijection with the disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆ‘</mo><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow></msub><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\sum_{n \in \mathbb N} X^n</annotation></semantics></math> (whose elements are pairs of a number and a list of that length), and is equal on the nose to the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆª</mo><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow></msub><msup><mi>X</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\cup_{n \in \mathbb N} X^n</annotation></semantics></math>.</p>
<p>On the other hand, the sets <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup><annotation encoding="application/x-tex">X^{* \leq n}</annotation></semantics></math> overlap: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>m</mi></mrow></msup><mo>âŠ†</mo><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^{* \leq m} \subseteq X^{* \leq n}</annotation></semantics></math> iff <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>â‰¤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \leq n</annotation></semantics></math>. The disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆ‘</mo><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow></msub><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{n \in \mathbb N} X^{* \leq n}</annotation></semantics></math> consists of pairs of a list and an upper bound on its length. But the non-disjoint union <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>âˆª</mo><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow></msub><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\cup_{n \in \mathbb N} X^{* \leq n}</annotation></semantics></math> is still equal on the nose to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>X</mi><mo>*</mo></msup><annotation encoding="application/x-tex">X^*</annotation></semantics></math>.</p>
<p>Suppose we want to talk about the length function, in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math> considered as a baby model of quantitative type theory. Consider the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>â„•</mi><mo>,</mo><msubsup><mi>X</mi><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb N, X^{* \leq n}_{n \in \mathbb N})</annotation></semantics></math>, which models an â€œirrelevant Sigma typeâ€ where an upper bound on the length is available at the type level but may not be used at the value level.</p>
<p>The set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>â„•</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math> is not a dependent type, so we consider it trivially <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-indexed, by the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>â„•</mi><mrow><mi>*</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\{ * \}, \mathbb N_{* \in \{ * \}})</annotation></semantics></math>. There is a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>â„•</mi><mo>,</mo><msubsup><mi>X</mi><mrow><mi>n</mi><mo>âˆˆ</mo><mi>â„•</mi></mrow><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msubsup><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>â„•</mi><mrow><mi>*</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbb N, X^{* \leq n}_{n \in \mathbb N}) \to (\{ * \}, \mathbb N_{* \in \{ * \}})</annotation></semantics></math>, given by the unique function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„•</mi><mo>â†’</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb N \to \{ * \}</annotation></semantics></math> together with the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>â„•</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math>-indexed family of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>âˆ’</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msup><mi>X</mi><mrow><mi>*</mi><mo>â‰¤</mo><mi>n</mi></mrow></msup><mo>â†’</mo><mi>â„•</mi></mrow><annotation encoding="application/x-tex">f (n, -) : X^{* \leq n} \to \mathbb N</annotation></semantics></math> that ignores <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and returns the actual length of the list. This satisfies the condition to be a morphism of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”‰</mi><mi>ğ”</mi><mi>ğ”ª</mi></mrow><annotation encoding="application/x-tex">\mathfrak{Fam}</annotation></semantics></math>.</p>
<p>We can say the same thing equivalently in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math>, where the corresponding object is the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>âŠ†</mo><mi>â„•</mi><mo>Ã—</mo><msup><mi>X</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">R \subseteq \mathbb N \times X^*</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">n R x</annotation></semantics></math> if the length of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The object corresponding to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>â„•</mi><annotation encoding="application/x-tex">\mathbb N</annotation></semantics></math> is the relation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>âŠ†</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo><mo>Ã—</mo><mi>â„•</mi></mrow><annotation encoding="application/x-tex">S \subseteq \{ * \} \times \mathbb N</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>*</mi><mi>S</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">* S n</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. The corresponding morphism is given by the unique function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„•</mi><mo>â†’</mo><mo stretchy="false" form="prefix">{</mo><mi>*</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathbb N \to \{ * \}</annotation></semantics></math> and the length function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>*</mo></msup><mo>â†’</mo><mi>â„•</mi></mrow><annotation encoding="application/x-tex">X^* \to \mathbb N</annotation></semantics></math>. This satisfies the condition to be a morphism of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow><mo>â†”</mo></msup><annotation encoding="application/x-tex">\mathbf{Set}^\leftrightarrow</annotation></semantics></math>.</p>
<p>Thatâ€™s all for today, but Iâ€™ll leave a puzzle. All of this was very heavily specialised to working concretely with sets. What structure could we put on a category in order that we can talk about â€œintersections of objectsâ€ in this way? <a href="https://www.brunogavranovic.com/">Bruno</a> suggested that what we need is a Grothendieck (possibly pre-)topology. I find this very plausible: two objects have nonempty overlap if they admit covering families with an object in common. But Iâ€™ll definitely leave the details of this for another day.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
