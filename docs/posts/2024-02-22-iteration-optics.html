<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Iteration with optics</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Iteration with optics</h1>
            <article>
    <section class="header">
        Posted on February 22, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/02/22/iteration-optics/">X-posted on the CyberCat Institute blog</a>)</p>
<p>In this post Iâ€™ll describe the theory of how to add iteration to categories of optics. Iteration is required for almost all applications of categorical cybernetics beyond game theory, and is something weâ€™ve been handling only semi-formally for some time. The only tool we need is already one we have inside the categorical cybernetics framework: parametrisation weighted by a lax monoidal functor. Iâ€™ll end with a conjecture that this is an instance of a general procedure to force states in a symmetric monoidal category.</p>
<p>This post is strongly inspired by the account of Moore machines in <a href="http://davidjaz.com/">David Jaz Myers</a>â€™ book <a href="http://davidjaz.com/Papers/DynamicalBook.pdf">Categorical Systems Theory</a>, and <a href="https://matteocapucci.wordpress.com/">Matteo</a>â€™s enthusiasm for it. Thereâ€™s probably a big connection to things like <a href="https://arxiv.org/abs/1903.01093">Delayed trace categories</a>, but I donâ€™t understand it yet.</p>
<p>The diagrams in this post are made with <a href="https://q.uiver.app/">Quiver</a> and <a href="https://varkor.github.io/tangle/">Tangle</a>.</p>
<h1 id="the-iteration-functor">The iteration functor</h1>
<p>For the purposes of this post, weâ€™ll be working with a symmetric monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, and the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> of monoidal optics over it. Objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> are pairs of objects of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math>, and morphisms are given by the coend formula</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>âˆ«</mo><mrow><mi>M</mi><mo>:</mo><mi>ğ’</mi></mrow></msub><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>M</mi><mo>âŠ—</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup><mo>,</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathbf{Optic} (\mathcal C) \left( \binom{X}{X'}, \binom{Y}{Y'} \right) = \int_{M : \mathcal C} \mathcal C (X, M \otimes Y) \times \mathcal C (M \otimes Y', X') </annotation></semantics></math></p>
<p>which amounts to saying that an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> is an equivalence class of triples</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>:</mo><mi>ğ’</mi><mo>,</mo><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>M</mi><mo>âŠ—</mo><mi>Y</mi><mo>,</mo><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>M</mi><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup><mo>â†’</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> (M : \mathcal C, f : X \to M \otimes Y, f' : M \otimes Y' \to X') </annotation></semantics></math></p>
<p>Iâ€™m pretty sure everything in this post works for other categories of bidirectional processes such as mixed optics and dependent lenses, this is just a setting to write it down which is both convenient and not at all obvious.</p>
<p>The <strong>iteration functor</strong> is a functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo>:</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Iter} : \mathbf{Optic} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math> defined on objects by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>âˆ«</mo><mrow><mi>M</mi><mo>:</mo><mi>ğ’</mi></mrow></msub><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mo>,</mo><mi>M</mi><mo>âŠ—</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo>âŠ—</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>,</mo><mi>M</mi><mo>âŠ—</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{Iter} \binom{X}{X'} = \int_{M : \mathcal C} \mathcal C (I, M \otimes X) \times \mathcal C (M \otimes X', M \otimes X) </annotation></semantics></math></p>
<p>We refer to elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Iter} \binom{X}{X'}</annotation></semantics></math> as <em>iteration data</em> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math>. We call the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> the <em>state space</em>, the morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>M</mi><mo>âŠ—</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x_0 : I \to M \otimes X</annotation></semantics></math> the <em>initial state</em> and the morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>M</mi><mo>âŠ—</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>â†’</mo><mi>M</mi><mo>âŠ—</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">i : M \otimes X' \to M \otimes X</annotation></semantics></math> the <em>iterator</em>.</p>
<p>Note that in the common case that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is cartesian monoidal, we can eliminate the coend to obtain a simpler characterisation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>Ã—</mo><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>,</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \mathrm{Iter} \binom{X}{X'} = \mathcal C (1, X) \times \mathcal C (X', X) </annotation></semantics></math></p>
<p>Given an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>N</mi><mo>,</mo><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>N</mi><mo>âŠ—</mo><mi>Y</mi><mo>,</mo><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>N</mi><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup><mo>â†’</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f = (N, f : X \to N \otimes Y, f' : N \otimes Y' \to X')</annotation></semantics></math>, we get a function</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \mathrm{Iter} (f) : \mathrm{Iter} \binom{X}{X'} \to \mathrm{Iter} \binom{Y}{Y'} </annotation></semantics></math></p>
<p>Namely, the state space is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>âŠ—</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M \otimes N</annotation></semantics></math>, the initial state is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mover><mo>â†’</mo><msub><mi>x</mi><mn>0</mn></msub></mover><mi>M</mi><mo>âŠ—</mo><mi>X</mi><mover><mo>â†’</mo><mrow><mi>M</mi><mo>âŠ—</mo><mi>f</mi></mrow></mover><mi>M</mi><mo>âŠ—</mo><mi>N</mi><mo>âŠ—</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex"> I \overset{x_0}\longrightarrow M \otimes X \xrightarrow{M \otimes f} M \otimes N \otimes Y </annotation></semantics></math></p>
<p>and the iterator is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>âŠ—</mo><mi>N</mi><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup><mover><mo>â†’</mo><mrow><mi>M</mi><mo>âŠ—</mo><msup><mi>f</mi><mo>â€²</mo></msup></mrow></mover><mi>M</mi><mo>âŠ—</mo><msup><mi>X</mi><mo>â€²</mo></msup><mover><mo>â†’</mo><mi>i</mi></mover><mi>M</mi><mo>âŠ—</mo><mi>X</mi><mover><mo>â†’</mo><mrow><mi>M</mi><mo>âŠ—</mo><mi>f</mi></mrow></mover><mi>M</mi><mo>âŠ—</mo><mi>N</mi><mo>âŠ—</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex"> M \otimes N \otimes Y' \xrightarrow{M \otimes f'} M \otimes X' \overset{i}\longrightarrow M \otimes X \xrightarrow{M \otimes f} M \otimes N \otimes Y </annotation></semantics></math></p>
<p>This is evidently functorial. Funnily enough, although the action of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{Iter}</annotation></semantics></math> on objects when <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> is cartesian is easier to understand, its action on morphisms is less obvious and is not <em>evidently</em> functorial, instead demanding a small proof.</p>
<h1 id="pairing-iterators-and-continuations">Pairing iterators and continuations</h1>
<p>We have an existing functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>:</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi mathvariant="normal">o</mi><mi mathvariant="normal">p</mi></mrow></msup><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">K : \mathbf{Optic} (\mathcal C)^{\mathrm{op}} \to \mathbf{Set}</annotation></semantics></math>, given on objects by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>ğ’</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">K \binom{X}{X'} = \mathcal C (X, X')</annotation></semantics></math>. This is the <em>continuation functor</em>, and it is the contravariant functor represented by the monoidal unit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>I</mi><mi>I</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{I}{I}</annotation></semantics></math>. (This functor first appeared in <a href="https://arxiv.org/abs/1711.07059">Morphisms of Open Games</a>.)</p>
<p>For the remainder of this section Iâ€™ll specialise to the case <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ’</mi><mo>=</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal C = \mathbf{Set}</annotation></semantics></math>, in which case an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> is determined by a pair of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>X</mi><mo>Ã—</mo><msup><mi>Y</mi><mo>â€²</mo></msup><mo>â†’</mo><msup><mi>X</mi><mo>â€²</mo></msup></mrow><annotation encoding="application/x-tex">f' : X \times Y' \to X'</annotation></semantics></math>, and iteration data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">i : \mathrm{Iter} \binom{X}{X'}</annotation></semantics></math> is determined by an initial value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x_0 : X</annotation></semantics></math> and a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><msup><mi>X</mi><mo>â€²</mo></msup><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">i : X' \to X</annotation></semantics></math>.</p>
<p>Given iteration data and a continuation that agree on their common boundary, we know enough to run the iteration and produce an infinite stream of values:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi>âˆ’</mi><mo stretchy="false" form="prefix">|</mo><mi>âˆ’</mi><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><msup><mi>X</mi><mi>Ï‰</mi></msup></mrow><annotation encoding="application/x-tex"> \left&lt; - | - \right&gt; : \mathrm{Iter} \binom{X}{X'} \times K \binom{X}{X'} \to X^\omega </annotation></semantics></math></p>
<p>Namely, this stream is defined corecursively by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>i</mi><mo stretchy="false" form="prefix">|</mo><mi>k</mi><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi>i</mi><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>i</mi><mo stretchy="false" form="prefix">|</mo><mi>k</mi><mo stretchy="true" form="postfix">âŸ©</mo></mrow></mrow><annotation encoding="application/x-tex"> \left&lt; x_0, i | k \right&gt; = x_0 : \left&lt; i (k (x_0)), i | k \right&gt; </annotation></semantics></math></p>
<p>This operation is natural (technically, <em>dinatural</em>): for any iteration data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">i : \mathrm{Iter} \binom{X}{X'}</annotation></semantics></math>, optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> and continuation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>:</mo><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">k : K \binom{Y}{Y'}</annotation></semantics></math>, we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mi>i</mi><mo stretchy="false" form="prefix">|</mo><mi>K</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mo>=</mo><msup><mi>f</mi><mi>Ï‰</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">âŸ¨</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mi>k</mi><mo stretchy="true" form="postfix">âŸ©</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \left&lt; i | K (f) (k) \right&gt; = f^\omega \left( \left&lt; \mathrm{Iter} (f) (i) | k \right&gt; \right) </annotation></semantics></math></p>
<p>where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mi>Ï‰</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msup><mi>X</mi><mi>Ï‰</mi></msup><mo>â†’</mo><msup><mi>Y</mi><mi>Ï‰</mi></msup></mrow><annotation encoding="application/x-tex">f^\omega (-) : X^\omega \to Y^\omega</annotation></semantics></math> means applying the forwards pass of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to every element of the stream. As a commuting diagram,</p>
<p><img src="../assets/posts/2024-02-22-iteration-optics/img1.png" /></p>
<p>Hereâ€™s a tiny implementation of the iteration functor and the pairing operator in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iterator</span> s t <span class="ot">=</span> <span class="dt">Iterator</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    initialState ::</span> s,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    updateState ::</span> t <span class="ot">-&gt;</span> s</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">mapIterator ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> <span class="dt">Iterator</span> s t <span class="ot">-&gt;</span> <span class="dt">Iterator</span> a b</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>mapIterator l (<span class="dt">Iterator</span> s f) <span class="ot">=</span> <span class="dt">Iterator</span> (s <span class="op">^#</span> l) (\b <span class="ot">-&gt;</span> (f (s <span class="op">&amp;</span> l <span class="op">.~</span> b)) <span class="op">^#</span> l)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">runIterator ::</span> <span class="dt">Iterator</span> s t <span class="ot">-&gt;</span> <span class="dt">Lens</span> s t () () <span class="ot">-&gt;</span> [s]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>runIterator (<span class="dt">Iterator</span> s f) l <span class="ot">=</span> s <span class="op">:</span> runIterator (<span class="dt">Iterator</span> (f (s <span class="op">&amp;</span> l <span class="op">.~</span> ())) f ) l</span></code></pre></div>
<h1 id="the-category-of-elements-of-iterator">The category of elements of Iterator</h1>
<p>The next step is to form the category of elements <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math>, also known as the discrete Grothendieck construction. This is a category whose objects are tuples <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( \binom{X}{X'}, i \right)</annotation></semantics></math> of an object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> and a choice of iteration data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">i : \mathrm{Iter} \binom{X}{X'}</annotation></semantics></math>. A morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left( \binom{X}{X'}, i \right) \to \left( \binom{Y}{Y'}, j \right)</annotation></semantics></math> is an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> with the property that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\mathrm{Iter} (f) (i) = j</annotation></semantics></math>, that is to say, the iteration data on the left and right boundary have to agree.</p>
<p>The functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo>:</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Iter} : \mathbf{Optic} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math> is lax monoidal: there is an evident natural way to combine pairs of iteration data into iteration data for pairs:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>âˆ‡</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>Ã—</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>Y</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \nabla : \mathrm{Iter} \binom{X}{X'} \times \mathrm{Iter} \binom{Y}{Y'} \to \mathrm{Iter} \binom{X \otimes Y}{X' \otimes Y'} </annotation></semantics></math></p>
<p>This means that the tensor product of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math> lifts to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math>, by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŠ—</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>Y</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mi>âˆ‡</mi><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \left( \binom{X}{X'}, i \right) \otimes \left( \binom{Y}{Y'}, j \right) = \left( \binom{X \otimes Y}{X' \otimes Y'}, i \nabla j \right) </annotation></semantics></math></p>
<p>The category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math> can essentially already describe iteration with optics, although in a slightly awkward way. Suppose we draw a string diagram that not coincidentally resembles a control loop:</p>
<p><img src="../assets/posts/2024-02-22-iteration-optics/img2.png" /></p>
<p>Here, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mo>â€²</mo></msup><annotation encoding="application/x-tex">f'</annotation></semantics></math> denote some morphisms <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : X \to Y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>Y</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f' : Y \to X</annotation></semantics></math> in our underlying category, and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>0</mn></msub><annotation encoding="application/x-tex">x_0</annotation></semantics></math> represents an initial state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x_0 : I \to X</annotation></semantics></math>.</p>
<p>Normally string diagrams denote morphisms of a monoidal category, but we make a cut just to the right of the backwards-to-forwards turning point, and consider that everything left of that is describing a boundary object. Namely in this case, we have the object <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>X</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( \binom{X}{X}, i \right)</annotation></semantics></math> where the iteration data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>X</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">i : \mathrm{Iter} \binom{X}{X}</annotation></semantics></math> is given by the state space <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>, the initial state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>I</mi><mo>âŠ—</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x_0 : I \to I \otimes X</annotation></semantics></math> and the iterator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>:</mo><mi>I</mi><mo>âŠ—</mo><mi>X</mi><mo>â†’</mo><mi>I</mi><mo>âŠ—</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">\mathrm{id} : I \otimes X \to I \otimes X</annotation></semantics></math>.</p>
<p><img src="../assets/posts/2024-02-22-iteration-optics/img3.png" /></p>
<p>The remainder of the string diagram to the right of the cut denotes an ordinary optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>X</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>I</mi><mi>I</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \binom{X}{X} \to \binom{I}{I}</annotation></semantics></math>, namely the one given by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><mi>f</mi><mo>,</mo><msup><mi>f</mi><mo>â€²</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f = (Y, f, f')</annotation></semantics></math>, with forwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>Y</mi><mo>âŠ—</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">f : X \to Y \otimes I</annotation></semantics></math> and backwards pass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>Y</mi><mo>âŠ—</mo><mi>I</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f' : Y \otimes I \to X</annotation></semantics></math>. This boils down to describing the composite morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>;</mo><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><mi>X</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f; f' : X \to X</annotation></semantics></math>.</p>
<p>Overall, we can read this diagram as denoting a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><mi>X</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>I</mi><mi>I</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f : \left( \binom{X}{X}, i \right) \to \left( \binom{I}{I}, \mathrm{Iter} (f) (i) \right)</annotation></semantics></math>. The iteration data on the right boundary is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>I</mi><mi>I</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Iter} (f) (i) : \mathrm{Iter} \binom{I}{I}</annotation></semantics></math>, which concretely has state space <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>, the initial state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>;</mo><mi>f</mi><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">x_0; f : I \to Y</annotation></semantics></math> and iterator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>;</mo><mi>f</mi><mo>:</mo><mi>Y</mi><mo>â†’</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f'; f : Y \to Y</annotation></semantics></math>.</p>
<p>This works in principle, but splitting the diagram between denoting an object and denoting a morphism is very non-standard. So far, this amounts to doing for the iteration functor what we did for the selection functions functor in section 6 of <a href="https://arxiv.org/abs/2105.06332">Towards Foundations of Categorical Cybernetics</a>.</p>
<h1 id="the-full-theory-of-iteration">The full theory of iteration</h1>
<p>Now we take the final step to fix the slight clunkiness of using <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math> as a model of iteration. This continues the firmly established pattern that categorical cybernetics contains only two ideas that get combined in more and more intricate ways: optics and parametrisation.</p>
<p>There is a strong monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mo>:</mo><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo>â†’</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi : \int \mathrm{Iter} \to \mathbf{Optic} (\mathcal C)</annotation></semantics></math> that forgets the iteration data, namely the discrete fibration <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ï€</mi><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\pi \left( \binom{X}{X'}, i \right) = \binom{X}{X'}</annotation></semantics></math>. This functor generates an action of the monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow><annotation encoding="application/x-tex">\int \mathrm{Iter}</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C)</annotation></semantics></math>, namely</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â€¢</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>Y</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>Y</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex"> \left( \binom{X}{X'}, i \right) \bullet \binom{Y}{Y'} = \binom{X \otimes Y}{X' \otimes Y'} </annotation></semantics></math></p>
<p>See section 5.5 of <a href="https://arxiv.org/abs/2203.16351">Actegories for the Working Amthematician</a> for far too much information about actegories of this form.</p>
<p>We now take the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>ğ</mi><mi>ğš</mi><mi>ğ«</mi><mi>ğš</mi></mrow><mrow><mo>âˆ«</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mrow></msub><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}_{\int \mathrm{Iter}} (\mathbf{Optic} (\mathcal C))</annotation></semantics></math> of parametrised morphisms generated by this action. We also refer to this kind of thing (parametrisation for the action generated by a discrete fibration) as the Para construction <em>weighted</em> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{Iter}</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>ğ</mi><mi>ğš</mi><mi>ğ«</mi><mi>ğš</mi></mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></msup><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}^\mathrm{Iter} (\mathbf{Optic} (\mathcal C))</annotation></semantics></math> - the name comes from it being a kind of <a href="https://ncatlab.org/nlab/show/weighted+limit">weighted limit</a> and I think the reference for this is <a href="https://www.brunogavranovic.com/">Bruno</a>â€™s PhD thesis, which is sadly unreleased as Iâ€™m writing this.</p>
<p>Working things through: an object of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>ğ</mi><mi>ğš</mi><mi>ğ«</mi><mi>ğš</mi></mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></msup><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}^\mathrm{Iter} (\mathbf{Optic} (\mathcal C))</annotation></semantics></math> is still a pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{X}{X'}</annotation></semantics></math>, but a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> consists of three things: another pair of objects <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Z</mi><msup><mi>Z</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\binom{Z}{Z'}</annotation></semantics></math>, iteration data <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Z</mi><msup><mi>Z</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">i : \mathrm{Iter} \binom{Z}{Z'}</annotation></semantics></math>, and an optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>Z</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>Z</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X \otimes Z}{X' \otimes Z'} \to \binom{Y}{Y'}</annotation></semantics></math>.</p>
<p>Now suppose we have a diagram of an open control loop, that is to say, a control loop that is open-as-in-systems (not to be confused with an <a href="https://en.wikipedia.org/wiki/Open-loop_controller">open loop controller</a>, which is unrelated):</p>
<p><img src="../assets/posts/2024-02-22-iteration-optics/img4.png" /></p>
<p>Here the primitive morphisms in the diagram are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>âŠ—</mo><mi>X</mi><mo>â†’</mo><mi>B</mi><mo>âŠ—</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">f : A \otimes X \to B \otimes Y</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>â€²</mo></msup><mo>:</mo><msup><mi>B</mi><mo>â€²</mo></msup><mo>âŠ—</mo><mi>Y</mi><mo>â†’</mo><msup><mi>A</mi><mo>â€²</mo></msup><mo>âŠ—</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f' : B' \otimes Y \to A' \otimes X</annotation></semantics></math>, and an initial state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x_0 : I \to X</annotation></semantics></math>. The idea is that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is the forwards pass, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mo>â€²</mo></msup><annotation encoding="application/x-tex">f'</annotation></semantics></math> is the backwards pass, and after the backwards pass comes another forwards pass but one time step in the future.</p>
<p>To make formal sense of this diagram, we imagine that we deform the backwards-to-forwards bend upwards, treating the state as a parameter, and then cut the diagram as we did before:</p>
<p><img src="../assets/posts/2024-02-22-iteration-optics/img5.png" /></p>
<p>Now we can read this off as a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>X</mi><msup><mi>X</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{X}{X'} \to \binom{Y}{Y'}</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>ğ</mi><mi>ğš</mi><mi>ğ«</mi><mi>ğš</mi></mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></msup><mo stretchy="false" form="prefix">(</mo><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}^\mathrm{Iter} (\mathbf{Optic} (\mathcal C))</annotation></semantics></math>. The (weighted) Para construction makes everything go smoothly, so this is an entirely standard string diagram with no funny stuff.</p>
<p>Technically categories of parametrised morphisms are always bicategories (or better, double categories), and I think this is a rare case where we actually want to quotient out all morphisms in the vertical direction, i.e.Â identify <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>f</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>Z</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>Z</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Z</mi><msup><mi>Z</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( f : \binom{X \otimes Z}{X' \otimes Z'} \to \binom{Y}{Y'}, i : \mathrm{Iter} \binom{Z}{Z'} \right)</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>g</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mrow><mi>X</mi><mo>âŠ—</mo><mi>W</mi></mrow><mrow><msup><mi>X</mi><mo>â€²</mo></msup><mo>âŠ—</mo><msup><mi>W</mi><mo>â€²</mo></msup></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Y</mi><msup><mi>Y</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>j</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>W</mi><msup><mi>W</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left( g : \binom{X \otimes W}{X' \otimes W'} \to \binom{Y}{Y'}, j : \mathrm{Iter} \binom{W}{W'} \right)</annotation></semantics></math> whenever there is <em>any</em> optic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>Z</mi><msup><mi>Z</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>â†’</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>W</mi><msup><mi>W</mi><mo>â€²</mo></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">h : \binom{Z}{Z'} \to \binom{W}{W'}</annotation></semantics></math> making <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\mathrm{Iter} (h) (i) = j</annotation></semantics></math> and commuting with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>. Coming back to our earlier picture of cutting a string diagram, this exactly says that we identify all of the different ways we could make the cut. In order to do this we change the base of enrichment along the functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mn>0</mn></msub><mo>:</mo><mrow><mi>ğ‚</mi><mi>ğš</mi><mi>ğ­</mi></mrow><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\pi_0 : \mathbf{Cat} \to \mathbf{Set}</annotation></semantics></math> taking each category to its set of connected components.</p>
<p>One final note: Almost everything in this post used nothing but the fact that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow><annotation encoding="application/x-tex">\mathrm{Iter}</annotation></semantics></math> is a lax monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ğ</mi><mi>ğ©</mi><mi>ğ­</mi><mi>ğ¢</mi><mi>ğœ</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{Optic} (\mathcal C) \to \mathbf{Set}</annotation></semantics></math>. With minimal translation, I think the entire thing works as a story about â€œforcing states in a symmetric monoidal categoryâ€: given any symmetric monoidal category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> and a lax monoidal functor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>ğ’</mi><mo>â†’</mo><mrow><mi>ğ’</mi><mi>ğ</mi><mi>ğ­</mi></mrow></mrow><annotation encoding="application/x-tex">F : \mathcal C \to \mathbf{Set}</annotation></semantics></math>, the category <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mi>ğ</mi><mi>ğš</mi><mi>ğ«</mi><mi>ğš</mi></mrow><mi>F</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>ğ’</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Para}^F (\mathcal C)</annotation></semantics></math> is equivalently described as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’</mi><annotation encoding="application/x-tex">\mathcal C</annotation></semantics></math> freely extended with a morphism <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>I</mi><mo>â†’</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">x : I \to X</annotation></semantics></math> for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x : F (X)</annotation></semantics></math>. Iâ€™ll leave this as a conjecture for somebody else to prove.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
