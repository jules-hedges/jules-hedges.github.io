<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Jules Hedges - Foundations of bidirectional programming II: Negative types</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/fonts.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Jules Hedges</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../papers.html">Papers</a>
                <a href="../blog.html">Blog</a>
                <a href="../forest/index.html">Forest</a>
                <a href="../links.html">Links</a>
            </nav>
        </header>

        <main role="main">
            <h1>Foundations of bidirectional programming II: Negative types</h1>
            <article>
    <section class="header">
        Posted on September  5, 2024
        
    </section>
    <section>
        <p>(<a href="https://cybercat.institute/2024/09/05/bidirectional-programming-ii/">X-posted on the CyberCat Institute blog</a>)</p>
<p>See <a href="../posts/2024-08-26-bidirectional-programming-i.html">part I</a> of this series</p>
<p>In this post we’ll begin designing a kernel language in which all programs are optics. What I mean by a “kernel language” is that it will serve as a compiler intermediate representation, with a surface language compiling down to it. I intend the surface language to be imperative style like the current Open Game Engine (with an approximately Python-like syntax), but the kernel language will reflect the category theory as closely as possible. I plan the kernel language to be well typed by construction, something that seems like overkill until I think about the problem of figuring out how pattern matching should work in a bidirectional language.</p>
<p>My first design choice is that <em>object language types denote pairs of metalanguage types</em>, with one denoting the forward part (sometimes I might call it the <em>covariant denotation</em>) and the other denoting the backward part (the <em>contravariant denotation</em>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Cov</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Con</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>The interpretation of a term will be a lens:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span> <span class="ot">:</span> <span class="dt">Term</span> xs y <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Cov</span> xs <span class="ot">-&gt;</span> (<span class="dt">Cov</span> y, <span class="dt">Con</span> y <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Con</span> xs)</span></code></pre></div>
<p>Here <code>All</code> is an Idris standard library function that combines a type-level map with cartesian product:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">All</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span> <span class="ot">:</span> <span class="dt">All</span> p []</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">(::)</span> <span class="ot">:</span> p x <span class="ot">-&gt;</span> <span class="dt">All</span> p xs <span class="ot">-&gt;</span> <span class="dt">All</span> p (x <span class="ot">::</span> xs)</span></code></pre></div>
<p>(Idris has what in Haskell would be called rebindable syntax switched on by default, so we can use the usual syntactic sugar for lists to refer to elements of <code>All</code>.)</p>
<p><code>eval</code> is a <em>well typed interpreter</em>, and is a placeholder while we prototype: much later, this is where the backend of the compiler will begin.</p>
<h2 id="the-logic-of-lenses">The logic of lenses</h2>
<p>My second design choice is that I want the basic product former to be interpreted as the <em>tensor product</em> of lenses, which is pairwise cartesian product on the covariant and contravariant parts. This is an uncontroversial choice, but importantly this product is symmetric monoidal but not cartesian, so it means that we are designing some kind of <em>linear type theory</em>.</p>
<p>My third design choice is that I want negation to be interpreted as swapping the covariant and contravariant parts. This sounds uncontroversial at first - many well known semantic categories do the same thing - until we notice that it is not functorial. That is to say, if we have a lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>Y</mi><mo>,</mo><msup><mi>Y</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, X') \to (Y, Y')</annotation></semantics></math> then in general we can’t make a lens between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>X</mi><mo>′</mo></msup><mo>,</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X', X)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>Y</mi><mo>′</mo></msup><mo>,</mo><mi>Y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(Y', Y)</annotation></semantics></math> in either direction. Years ago I wrote a paper called <a href="https://arxiv.org/abs/1704.02230">Coherence for lenses and open games</a> in which this non-functorial pair swapping featured heavily, and I still stake everything on the claim that it is the right way to go.</p>
<p>At this point we have enough to build a term language and its interpretation. I will add a single ground type which will be interpreted as purely covariant.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ty</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Unit</span> <span class="ot">:</span> <span class="dt">Ty</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ground</span> <span class="ot">:</span> <span class="dt">Ty</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Not</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tensor</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">mutual</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> <span class="dt">Unit</span> <span class="fu">=</span> <span class="dt">Unit</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> <span class="dt">Ground</span> <span class="fu">=</span> <span class="dt">Nat</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> (<span class="dt">Not</span> x) <span class="fu">=</span> <span class="dt">Con</span> x</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cov</span> (<span class="dt">Tensor</span> x y) <span class="fu">=</span> (<span class="dt">Cov</span> x, <span class="dt">Cov</span> y)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> <span class="dt">Unit</span> <span class="fu">=</span> <span class="dt">Unit</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> <span class="dt">Ground</span> <span class="fu">=</span> <span class="dt">Unit</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> (<span class="dt">Not</span> x) <span class="fu">=</span> <span class="dt">Cov</span> x</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span> (<span class="dt">Tensor</span> x y) <span class="fu">=</span> (<span class="dt">Con</span> x, <span class="dt">Con</span> y)</span></code></pre></div>
<p>Let’s think through the consequences of these choices. We think of <code>Tensor</code> as linear conjunction, so its neutral element <code>Unit</code> is linear truth. The interpretation of <code>Unit</code> is the pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 1)</annotation></semantics></math>, and so <code>Not Unit</code> - which we would think of as linear falsity - has the same interpretation. So we have a linear logic where falsity and truth coincide semantically. Similarly, the de Morgan dual of <code>Tensor</code>, which we would call linear disjunction, coincides with it semantically. So we have an inconsistent interpretation of linear logic. This is nowhere near as bad as it sounds, since many reasonable semantic categories do the same, but we need to keep it in mind.</p>
<p>Since <code>Tensor</code> is a perfectly cromulent symmetric monoidal product, its introduction and elimination rules will be exactly the same as the ones in my <a href="../posts/2024-08-26-bidirectional-programming-i.html">previous post</a>. But the negation rules are going to be quite a puzzle.</p>
<p>Our interpretation of negation is strictly involutive - swapping twice is a no-op - something we can call a <em>classical</em> linear negation. This means our semantics validates the principles of double negation introduction and double negation elimination: both of them are interpreted as an identity lens.</p>
<p>The <em>principle of explosion</em> says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg p</annotation></semantics></math> together entail falsity, for every proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>. Since falsity and truth coincide, for us the principle of explosion says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg p</annotation></semantics></math> together entail truth. This is a valid principle in our semantics. Suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> is interpreted as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, X')</annotation></semantics></math>, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⊗</mo><mo>¬</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p \otimes \neg p</annotation></semantics></math> is interpreted as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo>×</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X \times X', X' \times X)</annotation></semantics></math>. There is indeed a canonical lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo>×</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X \times X', X' \times X) \to (1, 1)</annotation></semantics></math>, namely the “turnaround” lens, which I normally call a <em>counit</em>.</p>
<p>In Idris, suppose we have</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">explosion</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a, <span class="dt">Not</span> a] <span class="dt">Unit</span></span></code></pre></div>
<p>Then we must have</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span> <span class="fu">explosion</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Cov</span> [a, <span class="dt">Not</span> a] <span class="ot">-&gt;</span> (<span class="dt">Unit</span>, <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Con</span> [a, <span class="dt">Not</span> a])</span></code></pre></div>
<p>which up to isomorphism reduces to</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span> <span class="fu">explosion</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> (<span class="dt">Cov</span> a, <span class="dt">Con</span> a) <span class="ot">-&gt;</span> (<span class="dt">Con</span> a, <span class="dt">Cov</span> a)</span></code></pre></div>
<p>Of course, we want to implement <code>eval</code> so that this gives us the swap function.</p>
<p>The de Morgan dual of the principle of explosion is the <em>principle of excluded middle</em>, which says that truth entails <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg p</annotation></semantics></math>. Remembering that our conjunction and disjunction coincide, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> has interpretation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(X, X')</annotation></semantics></math> then excluded middle would denote a lens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>×</mo><msup><mi>X</mi><mo>′</mo></msup><mo>,</mo><msup><mi>X</mi><mo>′</mo></msup><mo>×</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 1) \to (X \times X', X' \times X)</annotation></semantics></math>. In general there is no lens of this type, so our semantics does not validate excluded middle.</p>
<p>In Idris, suppose we had</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lem</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [] (<span class="dt">Tensor</span> a (<span class="dt">Not</span> a))</span></code></pre></div>
<p>Then we must have</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span> <span class="fu">lem</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Cov</span> [] <span class="ot">-&gt;</span> ((<span class="dt">Cov</span> a, <span class="dt">Con</span> a), (<span class="dt">Con</span> a, <span class="dt">Cov</span> a) <span class="ot">-&gt;</span> <span class="dt">All</span> <span class="dt">Con</span> [])</span></code></pre></div>
<p>which up to isomorphism reduces to</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">eval</span> <span class="fu">lem</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> (<span class="dt">Cov</span> a, <span class="dt">Con</span> a)</span></code></pre></div>
<p>which is impossible as soon as we introduce any types that are not pointed.</p>
<h2 id="a-logic-puzzle">A logic puzzle</h2>
<p>This suggests a <em>logic puzzle</em>: can we design a proof system for negation that validates double negation introduction, double negation elimination and the principle of explosion, but does not validate excluded middle?</p>
<p>After some tinkering I did indeed invent a system with these properties. Sadly it turned out to be a red herring, since it ended up proving these principles that are valid for lenses in terms of more primitive principles that are not valid for lenses. But I still think it’s an interesting enough sideline to report here.</p>
<p>The system I designed was a 2-sided hybrid of a natural deduction calculus and a sequent calculus, with general right-elimination, and both left-elimination and right-introduction restricted to empty sequents on the right. In standard proof theory syntax I would write it like this:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>,</mo><mi>φ</mi><mo>⊢</mo></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo>¬</mo><mi>φ</mi></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mi>I</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>,</mo><mo>¬</mo><mi>φ</mi><mo>⊢</mo></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>φ</mi></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>E</mi><mo stretchy="false" form="postfix">)</mo><mspace width="2.0em"></mspace><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>φ</mi><mo>,</mo><mi mathvariant="normal">Δ</mi><mspace width="2.0em"></mspace><msup><mi mathvariant="normal">Γ</mi><mo>′</mo></msup><mo>⊢</mo><mo>¬</mo><mi>φ</mi><mo>,</mo><msup><mi mathvariant="normal">Δ</mi><mo>′</mo></msup></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>,</mo><msup><mi mathvariant="normal">Γ</mi><mo>′</mo></msup><mo>⊢</mo><mi mathvariant="normal">Δ</mi><mo>,</mo><msup><mi mathvariant="normal">Δ</mi><mo>′</mo></msup></mrow></mfrac><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mi>E</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex"> \frac{\Gamma, \varphi \vdash}{\Gamma \vdash \neg \varphi} (RI) \qquad \frac{\Gamma, \neg \varphi \vdash}{\Gamma \vdash \varphi} (LE) \qquad \frac{\Gamma \vdash \varphi, \Delta \qquad \Gamma' \vdash \neg \varphi, \Delta'}{\Gamma, \Gamma' \vdash \Delta, \Delta'} (RE) </annotation></semantics></math></p>
<p>In Idris:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="ot">:</span> <span class="dt">Term</span> [x] [x]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LAct</span> <span class="ot">:</span> <span class="dt">Symmetric</span> xs' xs <span class="ot">-&gt;</span> <span class="dt">Term</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Term</span> xs' ys</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RAct</span> <span class="ot">:</span> <span class="dt">Term</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Symmetric</span> ys ys' <span class="ot">-&gt;</span> <span class="dt">Term</span> xs ys'</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotIntroR</span> <span class="ot">:</span> <span class="dt">Term</span> (x <span class="ot">::</span> xs) [] <span class="ot">-&gt;</span> <span class="dt">Term</span> xs [<span class="dt">Not</span> x]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotElimL</span> <span class="ot">:</span> <span class="dt">Term</span> (<span class="dt">Not</span> x <span class="ot">::</span> xs) [] <span class="ot">-&gt;</span> <span class="dt">Term</span> xs [x]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotElimR</span> <span class="ot">:</span> <span class="dt">Simplex</span> xs1 xs2 xs3 <span class="ot">-&gt;</span> <span class="dt">Simplex</span> ys1 ys2 ys3</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Term</span> xs1 (y <span class="ot">::</span> ys1) <span class="ot">-&gt;</span> <span class="dt">Term</span> xs2 (<span class="dt">Not</span> y <span class="ot">::</span> ys2) <span class="ot">-&gt;</span> <span class="dt">Term</span> xs3 ys3</span></code></pre></div>
<p><code>Symmetric</code> is the structure for permutations that I introduced in the <a href="../posts/2024-08-26-bidirectional-programming-i.html">previous post</a>.</p>
<p>Here are what our principles look like, together with some non-proofs that are ruled out by the restrictions on right-introduction and left-elimination:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dni</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a] [<span class="dt">Not</span> (<span class="dt">Not</span> a)]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>dni <span class="fu">=</span> <span class="dt">NotIntroR</span> (<span class="dt">LAct</span> (<span class="dt">Insert</span> (<span class="dt">There</span> <span class="dt">Here</span>) (<span class="dt">Insert</span> <span class="dt">Here</span> <span class="dt">Empty</span>)) </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                      (<span class="dt">NotElimR</span> (<span class="dt">Left</span> <span class="dt">Right</span>) <span class="dt">Right</span> <span class="dt">Var</span> <span class="dt">Var</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">dne</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [<span class="dt">Not</span> (<span class="dt">Not</span> a)] [a]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>dne <span class="fu">=</span> <span class="dt">NotElimL</span> (<span class="dt">NotElimR</span> (<span class="dt">Left</span> <span class="dt">Right</span>) <span class="dt">Right</span> <span class="dt">Var</span> <span class="dt">Var</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- ruled out by NotIntroR restriction</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- dne = NotElimR Right (Left Right) (NotIntroR Var) Var</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="fu">explosion</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a, <span class="dt">Not</span> a] []</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>explosion <span class="fu">=</span> <span class="dt">NotElimR</span> (<span class="dt">Left</span> <span class="dt">Right</span>) <span class="dt">Right</span> <span class="dt">Var</span> <span class="dt">Var</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="fu">lem</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [] [<span class="dt">Not</span> a, a]</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- ruled out by NotIntroR restriction</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- lem = NotIntroR Var</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- ruled out by NotElimL restriction</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- lem = NotElimL (NotElimL (NotElimR (Left Right) Right Var Var))</span></span></code></pre></div>
<p>Unfortunately, although my restricted left-elimination and right-introduction rules can be used to prove the semantically valid principles of double negation introduction and elimination, they are themselves not semantically valid. The problems start to appear once we add back in the rules for tensor, which in this 2-sided calculus are</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="ot">:</span> <span class="dt">Simplex</span> xs1 xs2 xs3 <span class="ot">-&gt;</span> <span class="dt">Simplex</span> ys1 ys2 ys3</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> xs1 (y1 <span class="ot">::</span> ys1) <span class="ot">-&gt;</span> <span class="dt">Term</span> xs2 (y2 <span class="ot">::</span> ys2) </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> xs3 (<span class="dt">Tensor</span> y1 y2 <span class="ot">::</span> ys3)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="ot">:</span> <span class="dt">Simplex</span> xs1 xs2 xs3 <span class="ot">-&gt;</span> <span class="dt">Simplex</span> ys1 ys2 ys3</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs1 (<span class="dt">Tensor</span> x y <span class="ot">::</span> ys1) <span class="ot">-&gt;</span> <span class="dt">Term</span> (x <span class="ot">::</span> y <span class="ot">::</span> xs2) ys2 </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs3 ys3</span></code></pre></div>
<p>Now we can write a bad term:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">bad</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [] [<span class="dt">Not</span> (<span class="dt">Tensor</span> a (<span class="dt">Not</span> a))]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>bad <span class="fu">=</span> <span class="dt">NotIntroR</span> (<span class="dt">TensorElim</span> (<span class="dt">Left</span> <span class="dt">Right</span>) <span class="dt">Right</span> <span class="dt">Var</span> explosion)</span></code></pre></div>
<p>Although these rules don’t seem to be strong enough to prove the distributive law between tensor and negation, semantically this is the same shape as excluded middle. I think it would be possible to restrict left-elimination and right-introduction differently to rule out this kind of thing, but only at the expense of leaving us with unprovable instances of double negation introduction and elimination.</p>
<h2 id="structurally-involutive-negation">Structurally involutive negation</h2>
<p>Although I would love to come up with a calculus that fulfills my requirements using pure logic, I currently believe that it’s impossible. So instead I will bring out the big guns, and use a <code>Structure</code>. The methodology I introduced in the previous post yields a clean conceptual separation into <em>syntax</em> and <em>logic</em>. If we want to say that two things are syntactically identical, for example permutations of contexts, we use a <code>Structure</code> to encode that. So what we are about to do is to encode a principle that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>¬</mo><mo>¬</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">\neg \neg p</annotation></semantics></math> are not merely <em>logically equivalent</em> but <em>syntactically identical</em>.</p>
<p>This is how we do it:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Parity</span> <span class="ot">:</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Id</span> <span class="ot">:</span> <span class="dt">Parity</span> x x</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Raise</span> <span class="ot">:</span> <span class="dt">Parity</span> x y <span class="ot">-&gt;</span> <span class="dt">Parity</span> x (<span class="dt">Not</span> (<span class="dt">Not</span> y))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lower</span> <span class="ot">:</span> <span class="dt">Parity</span> x y <span class="ot">-&gt;</span> <span class="dt">Parity</span> (<span class="dt">Not</span> (<span class="dt">Not</span> x)) y</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Involutive</span> <span class="ot">:</span> <span class="dt">Structure</span> <span class="dt">Ty</span> <span class="kw">where</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span> <span class="ot">:</span> <span class="dt">Involutive</span> [] []</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Insert</span> <span class="ot">:</span> <span class="dt">Parity</span> x y <span class="ot">-&gt;</span> <span class="dt">Insertion</span> y ys zs <span class="ot">-&gt;</span> <span class="dt">Involutive</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Involutive</span> (x <span class="ot">::</span> xs) zs</span></code></pre></div>
<p>An element of <code>Involutive xs ys</code> is a witness that <code>ys</code> is a permutation of <code>xs</code> but with an arbitrary number of double negatives inserted or removed.</p>
<p>With double negation introduction and elimination taken care of, all we have to do is to make a logic that validates the principle of explosion and not excluded middle, which is easy: it’s an ordinary 1-sided natural deduction calculus with the negation introduction rule omitted.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Ty</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> <span class="ot">:</span> <span class="dt">Term</span> [x] x</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Act</span> <span class="ot">:</span> <span class="dt">Involutive</span> xs ys <span class="ot">-&gt;</span> <span class="dt">Term</span> ys t <span class="ot">-&gt;</span> <span class="dt">Term</span> xs t</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NotElim</span> <span class="ot">:</span> {xs, ys <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> {<span class="kw">default</span> (simplex xs ys) prf <span class="ot">:</span> <span class="fu">_</span>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Term</span> xs t <span class="ot">-&gt;</span> <span class="dt">Term</span> ys (<span class="dt">Not</span> t) <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="fu">.</span>fst <span class="dt">Unit</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorIntro</span> <span class="ot">:</span> {xs, ys <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> {<span class="kw">default</span> (simplex xs ys) prf <span class="ot">:</span> <span class="fu">_</span>}</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Term</span> xs t <span class="ot">-&gt;</span> <span class="dt">Term</span> ys t' <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="fu">.</span>fst (<span class="dt">Tensor</span> t t')</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TensorElim</span> <span class="ot">:</span> {xs, ys <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> {<span class="kw">default</span> (simplex xs ys) prf <span class="ot">:</span> <span class="fu">_</span>}</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Term</span> xs (<span class="dt">Tensor</span> x y) <span class="ot">-&gt;</span> <span class="dt">Term</span> (x <span class="ot">::</span> y <span class="ot">::</span> ys) z <span class="ot">-&gt;</span> <span class="dt">Term</span> prf<span class="fu">.</span>fst z</span></code></pre></div>
<p>We can write exactly the terms that we want to:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dni</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a] (<span class="dt">Not</span> (<span class="dt">Not</span> a))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>dni <span class="fu">=</span> <span class="dt">Act</span> (<span class="dt">Insert</span> (<span class="dt">Raise</span> <span class="dt">Id</span>) <span class="dt">Here</span> <span class="dt">Empty</span>) <span class="dt">Var</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">dne</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [<span class="dt">Not</span> (<span class="dt">Not</span> a)] a</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>dne <span class="fu">=</span> <span class="dt">Act</span> (<span class="dt">Insert</span> (<span class="dt">Lower</span> <span class="dt">Id</span>) <span class="dt">Here</span> <span class="dt">Empty</span>) <span class="dt">Var</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="fu">explosion</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [a, <span class="dt">Not</span> a] <span class="dt">Unit</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>explosion <span class="fu">=</span> <span class="dt">NotElim</span> <span class="dt">Var</span> <span class="dt">Var</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="fu">lem</span> <span class="ot">:</span> {a <span class="ot">:</span> <span class="dt">Ty</span>} <span class="ot">-&gt;</span> <span class="dt">Term</span> [] (<span class="dt">Tensor</span> a (<span class="dt">Not</span> a))</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- impossible</span></span></code></pre></div>
<p>And it’s now possible to write a well typed interpreter for this definition of terms, although I’ll skip it here because it involves several pages of mostly tedious boilerplate code. In the next post we’ll add the missing scoping rules to our language, so that by the time we come back to the well typed interpreter in post number 4, we’ll be able to use it to do a little bit of differentiable programming.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> - <a href="../about.html">About this site</a>
        </footer>
    </body>
</html>
